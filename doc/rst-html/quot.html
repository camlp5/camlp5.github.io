

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quotations &mdash; Camlp5  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The revised syntax" href="revsynt.html" />
    <link rel="prev" title="Redefining OCaml syntax" href="redef.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Camlp5
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="strict.html">Transitional and Strict modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ptools.html">Parsing and Printing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="parsing-tools.html">Printing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="printing-tools.html">Parsing tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="language-extensions.html">Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="locations.html">Locations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ml_ast.html">Syntax tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="ast_transi.html">Syntax tree - transitional mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="ast_strict.html">Syntax tree - strict mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_ast.html">Syntax tree quotations in user syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="pcaml.html">The Pcaml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html">Directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntext.html">Extensions of syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="opretty.html">Extensions of printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="redef.html">Redefining OCaml syntax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Quotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="revsynt.html">The revised syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html">Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html#ocaml-scheme">OCaml                                     Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html#ocaml-lisp">OCaml                                     Lisp</a></li>
<li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragma.html">Pragma directive</a></li>
<li class="toctree-l2"><a class="reference internal" href="extfun.html">Extensible functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Future work</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Camlp5</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="language-extensions.html">Language extensions</a> &raquo;</li>
        
      <li>Quotations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/camlp5/camlp5/blob/master/doc/rstquot.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quotations">
<h1>Quotations<a class="headerlink" href="#quotations" title="Permalink to this headline">¶</a></h1>
<div class="docutils container" id="content">
<p class="top rubric" id="id1">Quotations</p>
<p>Quotations are a syntax extension in Camlp5 to build expressions and
patterns in any syntax independant from the one of OCaml. Quotations
are <em>expanded</em>, i.e. transformed, at parse time to produce normal
syntax trees, like the rest of the program. Quotations <em>expanders</em>
are normal OCaml functions writable by any programmer.</p>
<p>The aim of quotations is to use concrete syntax for manipulating
abstract values. That makes programs easier to write, read, modify,
and understand. The drawback is that quotations are linguistically
isolated from the rest of the program, in opposition to <a class="reference external" href="syntext.html">syntax
extensions</a>, which are included in the language.</p>
<p class="rubric" id="introduction">Introduction</p>
<p>A quotation is syntactically enclosed by specific quotes formed by
less (<code class="docutils literal"><span class="pre">&lt;</span></code>) and greater (<code class="docutils literal"><span class="pre">&gt;</span></code>) signs. Namely:</p>
<ul class="simple">
<li>starting with either “<code class="docutils literal"><span class="pre">&lt;&lt;</span></code>” or “<code class="docutils literal"><span class="pre">&lt;:ident&lt;</span></code>” where “<code class="docutils literal"><span class="pre">ident</span></code>”
is the quotation name,</li>
<li>ending with “<code class="docutils literal"><span class="pre">&gt;&gt;</span></code>”</li>
</ul>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;&lt;</span> \<span class="n">x</span><span class="o">.</span><span class="n">x</span> <span class="n">x</span> <span class="o">&gt;&gt;</span>
<span class="o">&lt;</span><span class="p">:</span><span class="n">foo</span><span class="o">&lt;</span> <span class="n">hello</span><span class="p">,</span> <span class="n">world</span> <span class="o">&gt;&gt;</span>
<span class="o">&lt;</span><span class="p">:</span><span class="n">bar</span><span class="o">&lt;</span> <span class="o">@</span><span class="c1">#$%;* &gt;&gt;</span>
</pre></div>
</div>
<p>The text between these particular parentheses can be any text. It may
contain enclosing quotations and the characters “<code class="docutils literal"><span class="pre">&lt;</span></code>”, “<code class="docutils literal"><span class="pre">&gt;</span></code>” and
“<code class="docutils literal"><span class="pre">\</span></code>” can be escaped by “<code class="docutils literal"><span class="pre">\</span></code>”. Notice that possible double-quote,
parentheses, OCaml comments do not necessarily have to balanced
inside them.</p>
<p>As far as the lexer is concerned, a quotation is just a kind of
string.</p>
<p class="rubric" id="quotation-expander">Quotation expander</p>
<p>Quotations are treated at parse time. Each quotation name is
associated with a <em>quotation expander</em>, a function transforming the
content of the quotation into a syntax tree. There are actually two
expanding functions, depending on whether the quotation is in the
context of an expression or if it is in the context of a pattern.</p>
<p>If a quotation has no associated quotation expander, a parsing error
is displayed and the compilation fails.</p>
<p>The quotation expander, or, rather, expanders, are functions taking
the quotation string as parameter and returning a syntax tree. There
is no constraint about which parsing technology is used. It can be
<a class="reference external" href="parsers.html">stream parsers</a>, <a class="reference external" href="grammars.html">extensible
grammars</a>, string scanning, ocamllex and yacc, any.</p>
<p>To build syntax trees, Camlp5 provides a way to easily build them see
the <a class="reference external" href="ml_ast.html">chapter</a> about them: it is possible to build
abstract syntax through concrete syntax using, precisely…
quotations.</p>
<p class="rubric" id="defining-a-quotation">Defining a quotation</p>
<p class="rubric" id="by-syntax-tree">By syntax tree</p>
<p>To define a quotation, it is necessary to program the quotation
expanders and to, finally, end the source code with a call to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Quotation</span><span class="o">.</span><span class="n">add</span> <span class="n">name</span> <span class="p">(</span><span class="n">Quotation</span><span class="o">.</span><span class="n">ExAst</span> <span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">f_patt</span><span class="p">));</span>
</pre></div>
</div>
<p>where “<code class="docutils literal"><span class="pre">name</span></code>” is the name of the quotation, and “<code class="docutils literal"><span class="pre">f_expr</span></code>” and
“<code class="docutils literal"><span class="pre">f_patt</span></code>” the respective quotations expanders for expressions and
patterns.</p>
<p>After compilation of the source file (without linking, i.e. using
option “-c” of the OCaml compiler), an object file is created (ending
with “.cmo”), which can be used as syntax extension <em>kit</em> of Camlp5.</p>
<p class="rubric" id="by-string">By string</p>
<p>There is another way to program the expander: a single function which
returns, not a syntax tree, but a string which is parsed, afterwards,
by the system. This function takes a boolean as first parameter
telling whether the quotation is in position of expression (True) or
in position of a pattern (False).</p>
<p>Used that way, the source file must end with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Quotation</span><span class="o">.</span><span class="n">add</span> <span class="n">name</span> <span class="p">(</span><span class="n">Quotation</span><span class="o">.</span><span class="n">ExStr</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>where “<code class="docutils literal"><span class="pre">f</span></code>” is that quotation expander. The advantage of this
second approach is that it is simple to understand and use. The
drawback is that there is no way to specify different source
locations for different parts of the quotation (what may be important
in semantic error messages).</p>
<p class="rubric" id="default-quotation">Default quotation</p>
<p>It is possible to use some quotation without its name. Use for that
the variable “<code class="docutils literal"><span class="pre">Quotation.default_quotation</span></code>”. For example, ending a
file by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Quotation</span><span class="o">.</span><span class="n">add</span> <span class="s2">&quot;foo&quot;</span> <span class="p">(</span><span class="n">Quotation</span><span class="o">.</span><span class="n">ExAst</span> <span class="p">(</span><span class="n">f_expr</span><span class="p">,</span> <span class="n">f_patt</span><span class="p">));</span>
<span class="n">Quotation</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">val</span> <span class="o">:=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>allows to use the quotation “foo” without its name, i.e.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;&lt;</span> <span class="o">...</span> <span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="p">:</span><span class="n">foo</span><span class="o">&lt;</span> <span class="o">...</span> <span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>If several files set the variable “<code class="docutils literal"><span class="pre">Quotation.default</span></code>”, the
default quotation applies to the last loaded one.</p>
<p class="rubric" id="antiquotations">Antiquotations</p>
<p>A quotation obeys its own rules of lexing and parsing. Its result is
a syntax tree, of type “<code class="docutils literal"><span class="pre">Pcaml.expr</span></code>” if the quotation is in the
context of an expression, or “<code class="docutils literal"><span class="pre">Pcaml.patt</span></code>” if the quotation is in
the context of a pattern.</p>
<p>It can be interesting to insert portions of expressions or patterns
of the enclosing context in its own quotations. For that, the syntax
of the quotation must define a syntax for <em>antiquotations areas</em>. It
can be, for example:</p>
<ul class="simple">
<li>A character introducing a variable: in this case the antiquotation
can just be a variable.</li>
<li>A couple of characters enclosing the antiquotations. For example,
in the predefined <a class="reference external" href="ml_ast.html">syntax tree quotations</a>, the
antiquotations are enclosed with dollar (“<code class="docutils literal"><span class="pre">$</span></code>”) signs.</li>
</ul>
<p>In quotations, the locations in the resulting syntax tree are all set
to the location of the quotation itself (if this resulting tree
contains locations, they are overwritten with this location).
Consequently, if there are semantic (typing) errors, the OCaml
compiler will underline the entire quotation.</p>
<p>But in antiquotations, since they can be inserted in the resulting
syntax tree, it is interesting to keep their initial quotations. For
that, the nodes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&lt;:expr&lt; $anti:...$ &gt;&gt;
&lt;:patt&lt; $anti:...$ &gt;&gt;
</pre></div>
</div>
<p>equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MLast</span><span class="o">.</span><span class="n">ExAnt</span> <span class="n">loc</span> <span class="o">...</span>
<span class="n">MLast</span><span class="o">.</span><span class="n">PaAnt</span> <span class="n">loc</span> <span class="o">...</span>
</pre></div>
</div>
<p>are provided (see <a class="reference external" href="ml_ast.html">syntax tree quotations</a>).</p>
<p>Let us take an example, without this node, and with this specific
node.</p>
<p>Let us consider an elementary quotation system whose contents is just
an antiquotation. This is just a school example, since the quotations
brackets are not necessary, in this case. But we are going to see how
the source code is underlined in errors messages.</p>
<p class="rubric" id="example-without-antiquotation-node">Example without antiquotation node</p>
<p>The code for this quotation is (file “qa.ml”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#load &quot;q_MLast.cmo&quot;;</span>
<span class="n">let</span> <span class="n">expr</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">Pcaml</span><span class="o">.</span><span class="n">expr</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span>
<span class="n">Quotation</span><span class="o">.</span><span class="n">add</span> <span class="s2">&quot;a&quot;</span> <span class="p">(</span><span class="n">Quotation</span><span class="o">.</span><span class="n">ExAst</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">fun</span> <span class="p">[]));</span>
</pre></div>
</div>
<p>The quotation expander “<code class="docutils literal"><span class="pre">expr</span></code>” just takes the string parameter
(the contents of the quotation), and returns the result of the
expression parser of the OCaml language.</p>
<p>Compilation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="o">-</span><span class="n">c</span> <span class="n">qa</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>Let us test it in the toplevel with a voluntary typing error:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ocaml -I +camlp5 camlp5r.cma
        Objective Caml version ...

        Camlp5 Parsing version ...

# #load &quot;qa.cmo&quot;;
# let x = &quot;abc&quot; and y = 25 in &lt;:a&lt; x ^ y &gt;&gt;;
Characters 28-41:
  let x = &quot;abc&quot; and y = 25 in &lt;:a&lt; x ^ y &gt;&gt;;
                              ^^^^^^^^^^^^^
This expression has type int but is here used with type string
</pre></div>
</div>
<p>We observe that the full quotation is underlined, although it
concerns only the variable “<code class="docutils literal"><span class="pre">y</span></code>”.</p>
<p class="rubric" id="example-with-antiquotation-node">Example with antiquotation node</p>
<p>Let us consider this second version (file “qb.ml”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#load &quot;q_MLast.cmo&quot;;
let expr s =
  let ast = Grammar.Entry.parse Pcaml.expr (Stream.of_string s) in
  let loc = Ploc.make 1 0 (0, String.length s) in
  &lt;:expr&lt; $anti:ast$ &gt;&gt;
in
Quotation.add &quot;b&quot; (Quotation.ExAst (expr, fun []));
</pre></div>
</div>
<p>As above, the quotation expander “<code class="docutils literal"><span class="pre">expr</span></code>” takes the string
parameter (the contents of the quotation) and applies the expression
parser of the OCaml language. Its result, instead of being returned
as it is, is enclosed with the antiquotation node. (The location
built is the location of the whole string.)</p>
<p>Compilation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="o">-</span><span class="n">c</span> <span class="n">qb</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>Now the same test gives:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ocaml -I +camlp5 camlp5r.cma
        Objective Caml version ...

        Camlp5 Parsing version ...

# #load &quot;qb.cmo&quot;;
# let x = &quot;abc&quot; and y = 25 in &lt;:b&lt; x ^ y &gt;&gt;;
Characters 37-38:
  let x = &quot;abc&quot; and y = 25 in &lt;:b&lt; x ^ y &gt;&gt;;
                                       ^
This expression has type int but is here used with type string
</pre></div>
</div>
<p>Notice that, now, only the variable “<code class="docutils literal"><span class="pre">y</span></code>” is underlined.</p>
<p class="rubric" id="in-conclusion">In conclusion</p>
<p>In the resulting tree of the quotation expander:</p>
<ul class="simple">
<li>only portions of this tree, which are sons of the expr and patt
antiquotation nodes, have the right location they have in the
quotation (provided the quotation expander gives it the right
location of the antiquation in the quotation),</li>
<li>the other nodes inherit, as location, the location of the full
quotation.</li>
</ul>
<p class="rubric" id="locations-in-quotations-and-antiquotations">Locations in quotations and antiquotations</p>
<p>This section explains in details the problem of locations in
quotations and antiquotations. It is designed for programmers of
quotation expanders.</p>
<p>Locations are the difficult point in quotations and antiquotations.
If they are not set correctly, error messages may highlight wrong
parts of the source.</p>
<p>The locations are controlled:</p>
<ul class="simple">
<li>for syntax errors: by the exception “<code class="docutils literal"><span class="pre">Ploc.Exc</span></code>”, raised by the
function “<code class="docutils literal"><span class="pre">Ploc.raise</span></code>”,</li>
<li>for typing errors, by the syntax tree nodes
“<code class="docutils literal"><span class="pre">&lt;:expr&lt;&nbsp;$anti:...$&nbsp;&gt;&gt;</span></code>” and “<code class="docutils literal"><span class="pre">&lt;:meta&lt;&nbsp;$anti:...$&nbsp;&gt;&gt;</span></code>”.</li>
</ul>
<p>If the quotation expander never uses them, all syntax and typing
errors highlight the whole quotation.</p>
<p>Remark that in <a class="reference external" href="grammars.html">extensible grammars</a>, syntax errors
are automatically enclosed by the exception “<code class="docutils literal"><span class="pre">Ploc.Exc</span></code>”.
Therefore, if the quotation is parsed by an extensible grammar entry,
this exception can be raised.</p>
<p>In the syntax tree nodes “<code class="docutils literal"><span class="pre">&lt;:expr&lt;&nbsp;$anti:...$&nbsp;&gt;&gt;</span></code>” and
“<code class="docutils literal"><span class="pre">&lt;:meta&lt;&nbsp;$anti:...$&nbsp;&gt;&gt;</span></code>”, the location is indicated by the
implicit variable named “<code class="docutils literal"><span class="pre">loc</span></code>”. Their usage is therefore something
like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let loc = ...computation of the location... in
&lt;:expr&lt; $anti:...$ &gt;&gt;
</pre></div>
</div>
<p class="rubric" id="in-the-quotation">In the quotation</p>
<p>All locations must be computed <em>relatively to the quotation string</em>.
The quotation string is the string between “<code class="docutils literal"><span class="pre">&lt;&lt;</span></code>” or “<code class="docutils literal"><span class="pre">&lt;:name&lt;</span></code>”
and “<code class="docutils literal"><span class="pre">&gt;&gt;</span></code>” (excluded), the first character of this string being at
location zero.</p>
<p>The quotation system automatically shifts all locations with the
location of the quotation: the programmer of the quotation expander
does not therefore need to care about where the quotation appears in
the source.</p>
<p class="rubric" id="in-antiquotations">In antiquotations</p>
<p>In antiquotations, it is important to control how the antiquotation
string is parsed. For example, if the function parsing the
antiquotation string raises “<code class="docutils literal"><span class="pre">Ploc.Exc</span></code>”, the location of this
exception must be shifted with the location of the antiquotation in
the quotation.</p>
<p>For example, let us suppose that the source contains:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">^</span><span class="n">ijk</span><span class="o">^</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>where the antiquotation is specified between the caret (“<code class="docutils literal"><span class="pre">^</span></code>”)
characters. The antiquotation string is “<code class="docutils literal"><span class="pre">ijk</span></code>”. It can be built in
the quotation expander by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="p">:</span><span class="n">expr</span><span class="o">&lt;</span> <span class="n">ijk</span> <span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>If used just like this, without the “<code class="docutils literal"><span class="pre">&lt;:expr&lt;</span> <span class="pre">$anti:x$</span> <span class="pre">&gt;&gt;</span></code>”, in
case of typing error (for example if the variable “<code class="docutils literal"><span class="pre">ijk</span></code>” is
unbound), the OCaml error message will be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">^</span><span class="n">ijk</span><span class="o">^</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
<span class="o">^^^^^^^^^^^^^^^^^^^</span>
<span class="n">Unbound</span> <span class="n">value</span> <span class="n">ijk</span>
</pre></div>
</div>
<p>To put a location to “<code class="docutils literal"><span class="pre">ijk</span></code>”, since its location in the quotation
is “<code class="docutils literal"><span class="pre">(5,</span> <span class="pre">8)</span></code>” (the “<code class="docutils literal"><span class="pre">i</span></code>” being the 5th characater of the
quotation string, starting at zero), the quotation expander can build
it like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let e = &lt;:expr&lt; ijk &gt;&gt; in
let loc = Ploc.make_unlined (5, 8) in
&lt;:expr&lt; $anti:e$ &gt;&gt;
</pre></div>
</div>
<p>In this case, the possible typing error message will be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;&lt;</span> <span class="n">abc</span><span class="o">^</span><span class="n">ijk</span><span class="o">^</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
       <span class="o">^^^</span>
<span class="n">Unbound</span> <span class="n">value</span> <span class="n">ijk</span>
</pre></div>
</div>
<p>This case is simple, since the antiquotation is just an identifier,
and there is no parser computing it.</p>
<p>If the antiquotation has to be parsed, for example if it is a
complicated expression, there are two points to care about:</p>
<p>First, the syntax error messages. If the parser of the antiquotation
raises “<code class="docutils literal"><span class="pre">Ploc.Exc</span></code>”, its location is relative to the antiquotation.
It must therefore be shifted to correspond to a location in the
quotation. If “<code class="docutils literal"><span class="pre">f</span></code>” is the parsing function and “<code class="docutils literal"><span class="pre">sh</span></code>” the shift
of the <em>antiquotation</em> in the <em>quotation</em> (whose value is “<code class="docutils literal"><span class="pre">5</span></code>” in
the example), the code must be something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="n">f</span> <span class="p">()</span> <span class="k">with</span>
<span class="p">[</span> <span class="n">Ploc</span><span class="o">.</span><span class="n">Exc</span> <span class="n">loc</span> <span class="n">exc</span> <span class="o">-&gt;</span> <span class="n">Ploc</span><span class="o">.</span><span class="k">raise</span> <span class="p">(</span><span class="n">Ploc</span><span class="o">.</span><span class="n">shift</span> <span class="n">sh</span> <span class="n">loc</span><span class="p">)</span> <span class="n">exc</span> <span class="p">]</span>
</pre></div>
</div>
<p>Second, the typing error messages. Here, the above code with
“<code class="docutils literal"><span class="pre">&lt;:expr&lt;&nbsp;$anti:e$&nbsp;&gt;&gt;</span></code>” can apply to the resulting tree.</p>
<p>The complete code, taking the possible syntax error messages and the
possible typing error messages into account, can be (where “<code class="docutils literal"><span class="pre">len</span></code>”
is the antiquotation length):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let e =
  try f () with
  [ Ploc.Exc loc exc -&gt; Ploc.raise (Ploc.shift sh loc) exc ]
in
let loc = Ploc.make_unlined (sh, sh + len) in
&lt;:expr&lt; $anti:e$ &gt;&gt;
</pre></div>
</div>
<p class="rubric" id="located-errors">Located errors</p>
<p>If the quotation expander raises an exception, by default, the whole
quotation is underlined:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ cat foo.ml
#load &quot;q_MLast.cmo&quot;;
let expr s = raise (Failure &quot;hello&quot;) in
Quotation.add &quot;a&quot; (Quotation.ExAst (expr, fun []));

$ ocaml -I +camlp5 camlp5r.cma
        Objective Caml version ...

        Camlp5 Parsing version ...

# #use &quot;foo.ml&quot;;
- : unit = ()
# &lt;:a&lt; good morning &gt;&gt;;
Toplevel input:
# &lt;:a&lt; good morning &gt;&gt;;
  ^^^^^^^^^^^^^^^^^^^^
While expanding quotation &quot;a&quot;:
Failure: hello
</pre></div>
</div>
<p>To specify a location of the exception, use the function
“<code class="docutils literal"><span class="pre">Ploc.raise</span></code>” instead of “<code class="docutils literal"><span class="pre">raise</span></code>”. In this example, let us
suppose that we want only the characters 5 to 7 are underlined. This
can be done like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ cat foo.ml
#load &quot;q_MLast.cmo&quot;;
let expr s = Ploc.raise (Ploc.make 1 0 (5, 7)) (Failure &quot;hello&quot;) in
Quotation.add &quot;a&quot; (Quotation.ExAst (expr, fun []));

$ ledit ocaml -I +camlp5 camlp5r.cma
        Objective Caml version ...

        Camlp5 Parsing version ...

# #use &quot;foo.ml&quot;;
- : unit = ()
# &lt;:a&lt; good morning &gt;&gt;;
Toplevel input:
# &lt;:a&lt; good morning &gt;&gt;;
           ^^
While expanding quotation &quot;a&quot;:
Failure: hello
</pre></div>
</div>
<p class="rubric" id="the-quotation-module">The Quotation module</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">expander</span> <span class="o">=</span>
  <span class="p">[</span> <span class="n">ExStr</span> <span class="n">of</span> <span class="nb">bool</span> <span class="o">-&gt;</span> <span class="n">string</span> <span class="o">-&gt;</span> <span class="n">string</span>
  <span class="o">|</span> <span class="n">ExAst</span> <span class="n">of</span> <span class="p">(</span><span class="n">string</span> <span class="o">-&gt;</span> <span class="n">MLast</span><span class="o">.</span><span class="n">expr</span> <span class="o">*</span> <span class="n">string</span> <span class="o">-&gt;</span> <span class="n">MLast</span><span class="o">.</span><span class="n">patt</span><span class="p">)</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
<p>Is the type for quotation expander kinds:</p>
<ul class="simple">
<li>“<code class="docutils literal"><span class="pre">Quotation.ExStr</span> <span class="pre">exp</span></code>” corresponds to an expander “<code class="docutils literal"><span class="pre">exp</span></code>”
returning a string which is parsed by the system to create a
syntax tree. Its boolean parameter tells whether the quotation is
in position of an expression (True) or in position of a pattern
(False). Quotations expanders created this way may work for some
particular OCaml syntax, and not for another one (e.g. may work
when used with revised syntax and not when used with normal
syntax, and conversely).</li>
<li>“<code class="docutils literal"><span class="pre">Quotation.ExAst</span> <span class="pre">(expr_exp,</span> <span class="pre">patt_exp)</span></code>” corresponds to
expanders returning syntax trees, therefore not necessitating to
be parsed afterwards. The function “<code class="docutils literal"><span class="pre">expr_exp</span></code>” is called when
the quotation is in position of an expression, and “<code class="docutils literal"><span class="pre">patt_exp</span></code>”
when the quotation is in position of a pattern. Quotation
expanders created this way are independent from the enclosing
syntax.</li>
</ul>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">value</span> <span class="pre">add</span> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">-&gt;</span> <span class="pre">expander</span> <span class="pre">-&gt;</span> <span class="pre">unit;</span></code></dt>
<dd>“<code class="docutils literal"><span class="pre">Quotation.add</span> <span class="pre">name</span> <span class="pre">exp</span></code>” adds the quotation “<code class="docutils literal"><span class="pre">name</span></code>”
associated with the expander “<code class="docutils literal"><span class="pre">exp</span></code>”.</dd>
<dt><code class="docutils literal"><span class="pre">value</span> <span class="pre">find</span> <span class="pre">:</span> <span class="pre">string</span> <span class="pre">-&gt;</span> <span class="pre">expander;</span></code></dt>
<dd>“<code class="docutils literal"><span class="pre">Quotation.find</span> <span class="pre">name</span></code>” returns the quotation expander of the
given name.</dd>
<dt><code class="docutils literal"><span class="pre">value</span> <span class="pre">default</span> <span class="pre">:</span> <span class="pre">ref</span> <span class="pre">string;</span></code></dt>
<dd>The name of the default quotation : it is possible to use this
quotation between “<code class="docutils literal"><span class="pre">&lt;&lt;</span></code>” and “<code class="docutils literal"><span class="pre">&gt;&gt;</span></code>” without having to specify
its name.</dd>
<dt><code class="docutils literal"><span class="pre">value</span> <span class="pre">translate</span> <span class="pre">:</span> <span class="pre">ref</span> <span class="pre">(string</span> <span class="pre">-&gt;</span> <span class="pre">string);</span></code></dt>
<dd>Function translating quotation names; default = identity. Used in
the predefined quotation “<code class="docutils literal"><span class="pre">q_phony.cmo</span></code>”. See below.</dd>
</dl>
<p>Some other useful functions for quotations are defined in the module
“<code class="docutils literal"><span class="pre">Pcaml</span></code>”. See the chapter “<a class="reference external" href="pcaml.html">The Pcaml module</a>”,
section “Quotation management”.</p>
<p class="rubric" id="predefined-quotations">Predefined quotations</p>
<p class="rubric" id="q-mlast-cmo">q_MLast.cmo</p>
<p>This extension kit add quotations of OCaml syntax tree, allowing to
use concrete syntax to represent abstract syntax. See the chapter
<a class="reference external" href="ml_ast.html">Syntax tree</a>.</p>
<p class="rubric" id="q-ast-cmo">q_ast.cmo</p>
<p>As with the previous quotation, this extension kit add quotations of
OCaml syntax tree, but in the current user syntax with all
extensions, the previous one being restricted to revised syntax
without extension. See the chapters <a class="reference external" href="ml_ast.html">Syntax tree</a> and
<a class="reference external" href="q_ast.html">Syntax tree quotations in user syntax</a>.</p>
<p class="rubric" id="q-phony-cmo">q_phony.cmo</p>
<p>This extension kit is designed for pretty printing and must be loaded
after a language pretty printing kit (in normal or in revised
syntax). It prevents the expansions of quotations, transforming them
into variables. The pretty printing then keeps the initial (source)
form.</p>
<p>The <a class="reference external" href="macros.html">macros</a> (extension “<code class="docutils literal"><span class="pre">pa_macro.cmo</span></code>”) are also
displayed in their initial form, instead of expanded.</p>
<p class="rubric" id="a-full-example-lambda-terms">A full example: lambda terms</p>
<p>This example allows to represent lambda terms by a concrete syntax
and to be able to combine them using antiquotations.</p>
<p>A lambda term is defined like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">term</span> <span class="o">=</span>
  <span class="p">[</span> <span class="n">Lam</span> <span class="n">of</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">term</span>
  <span class="o">|</span> <span class="n">App</span> <span class="n">of</span> <span class="n">term</span> <span class="ow">and</span> <span class="n">term</span>
  <span class="o">|</span> <span class="n">Var</span> <span class="n">of</span> <span class="n">string</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">fst</span> <span class="o">=</span> <span class="n">Lam</span> <span class="s2">&quot;x&quot;</span> <span class="p">(</span><span class="n">Lam</span> <span class="s2">&quot;y&quot;</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;x&quot;</span><span class="p">));</span>
<span class="n">value</span> <span class="n">snd</span> <span class="o">=</span> <span class="n">Lam</span> <span class="s2">&quot;x&quot;</span> <span class="p">(</span><span class="n">Lam</span> <span class="s2">&quot;y&quot;</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;y&quot;</span><span class="p">));</span>
<span class="n">value</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">Lam</span> <span class="s2">&quot;x&quot;</span> <span class="p">(</span><span class="n">App</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;x&quot;</span><span class="p">));</span>
<span class="n">value</span> <span class="n">omega</span> <span class="o">=</span> <span class="n">App</span> <span class="n">delta</span> <span class="n">delta</span><span class="p">;</span>
<span class="n">value</span> <span class="n">comb_s</span> <span class="o">=</span>
  <span class="n">Lam</span> <span class="s2">&quot;x&quot;</span>
    <span class="p">(</span><span class="n">Lamb</span> <span class="s2">&quot;y&quot;</span>
       <span class="p">(</span><span class="n">Lamb</span> <span class="s2">&quot;z&quot;</span>
          <span class="p">(</span><span class="n">App</span> <span class="p">(</span><span class="n">App</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;y&quot;</span><span class="p">))</span> <span class="p">(</span><span class="n">App</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">Var</span> <span class="s2">&quot;z&quot;</span><span class="p">)))));</span>
</pre></div>
</div>
<p>Since combinations of lambda term may be complicated, The idea is to
represent them by quotations in concrete syntax. We want to be able
to write the examples above like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">fst</span> <span class="o">=</span> <span class="o">&lt;&lt;</span> \<span class="n">x</span><span class="o">.</span>\<span class="n">y</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">value</span> <span class="n">snd</span> <span class="o">=</span> <span class="o">&lt;&lt;</span> \<span class="n">x</span><span class="o">.</span>\<span class="n">y</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">value</span> <span class="n">delta</span> <span class="o">=</span> <span class="o">&lt;&lt;</span> \<span class="n">x</span><span class="o">.</span><span class="n">x</span> <span class="n">x</span> <span class="o">&gt;&gt;</span>
<span class="n">value</span> <span class="n">omega</span> <span class="o">=</span> <span class="o">&lt;&lt;</span> <span class="o">^</span><span class="n">delta</span> <span class="o">^</span><span class="n">delta</span> <span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">value</span> <span class="n">comb_s</span> <span class="o">=</span> <span class="o">&lt;&lt;</span> \<span class="n">x</span><span class="o">.</span>\<span class="n">y</span><span class="o">.</span>\<span class="n">z</span><span class="o">.</span><span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)(</span><span class="n">x</span> <span class="n">z</span><span class="p">)</span> <span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>which is a classic representation of lambda terms.</p>
<p>Notice, in the definition of “<code class="docutils literal"><span class="pre">omega</span></code>”, the use of the caret
(“<code class="docutils literal"><span class="pre">^</span></code>”) sign to specify antiquotations. Notice also the simplicity
of the representation of the expression defining “<code class="docutils literal"><span class="pre">comb_s</span></code>”.</p>
<p>Here is the code of the quotation expander, term.ml. The expander
uses the <a class="reference external" href="grammars.html">extensible grammars</a>. It has its own
lexer (using the <a class="reference external" href="lexers.html">stream lexers</a>) because the lexer
of OCaml programs (“<code class="docutils literal"><span class="pre">Plexer.gmake</span> <span class="pre">()</span></code>”), cannot recognize the
backslashes alone.</p>
<p class="rubric" id="lexer">Lexer</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>(* lexer *)

#load &quot;pa_lexer.cmo&quot;;

value rec ident =
  lexer
  [ [ &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39; | &#39;-&#39; | &#39;_&#39; | &#39;\128&#39;-&#39;\255&#39; ]
    ident!
  | ]
;

value empty _ = parser [: _ = Stream.empty :] -&gt; [];

value rec next_tok =
  lexer
  [ &quot;\\&quot; -&gt; (&quot;BSLASH&quot;, &quot;&quot;)
  | &quot;^&quot; -&gt; (&quot;CARET&quot;, &quot;&quot;)
  | &#39;a&#39;-&#39;z&#39; ident! -&gt; (&quot;IDENT&quot;, $buf)
  | &quot;(&quot; -&gt; (&quot;&quot;, &quot;(&quot;)
  | &quot;)&quot; -&gt; (&quot;&quot;, &quot;)&quot;)
  | &quot;.&quot; -&gt; (&quot;&quot;, &quot;.&quot;)
  | empty -&gt; (&quot;EOS&quot;, &quot;&quot;)
  | -&gt; raise (Stream.Error &quot;lexing error: bad character&quot;) ]
;

value rec skip_spaces =
  lexer
  [ &quot; &quot;/ skip_spaces!
  | &quot;\n&quot;/ skip_spaces!
  | &quot;\r&quot;/ skip_spaces! | ]
;

value record_loc loct i (bp, ep) = do {
  if i &gt;= Array.length loct.val then do {
    let newt =
      Array.init (2 * Array.length loct.val + 1)
        (fun i -&gt;
           if i &lt; Array.length loct.val then loct.val.(i)
           else Ploc.dummy)
    in
    loct.val := newt;
  }
  else ();
  loct.val.(i) := Ploc.make_unlined (bp, ep)
};

value lex_func cs =
  let loct = ref [| |] in
  let ts =
    Stream.from
      (fun i -&gt; do {
         ignore (skip_spaces $empty cs : Plexing.Lexbuf.t);
         let bp = Stream.count cs in
         let r = next_tok $empty cs in
         let ep = Stream.count cs in
         record_loc loct i (bp, ep);
         Some r
       })
  in
  let locf i =
    if i &lt; Array.length loct.val then loct.val.(i) else Ploc.dummy
  in
  (ts, locf)
;

value lam_lex =
  {Plexing.tok_func = lex_func;
   Plexing.tok_using _ = (); Plexing.tok_removing _ = ();
   Plexing.tok_match = Plexing.default_match;
   Plexing.tok_text = Plexing.lexer_text;
   Plexing.tok_comm = None}
;
</pre></div>
</div>
<p class="rubric" id="parser">Parser</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>(* parser *)

#load &quot;pa_extend.cmo&quot;;
#load &quot;q_MLast.cmo&quot;;

value g = Grammar.gcreate lam_lex;
value expr_term_eos = Grammar.Entry.create g &quot;term&quot;;
value patt_term_eos = Grammar.Entry.create g &quot;term&quot;;

EXTEND
  GLOBAL: expr_term_eos patt_term_eos;
  expr_term_eos:
    [ [ x = expr_term; EOS -&gt; x ] ]
  ;
  expr_term:
    [ [ BSLASH; i = IDENT; &quot;.&quot;; t = SELF -&gt; &lt;:expr&lt; Lam $str:i$ $t$ &gt;&gt; ]
    | [ x = SELF; y = SELF -&gt; &lt;:expr&lt; App $x$ $y$ &gt;&gt; ]
    | [ i = IDENT -&gt; &lt;:expr&lt; Var $str:i$ &gt;&gt;
      | CARET; r = expr_antiquot -&gt; r
      | &quot;(&quot;; t = SELF; &quot;)&quot; -&gt; t ] ]
  ;
  expr_antiquot:
    [ [ i = IDENT -&gt;
         let r =
           let loc = Ploc.make_unlined (0, String.length i) in
           &lt;:expr&lt; $lid:i$ &gt;&gt;
         in
         &lt;:expr&lt; $anti:r$ &gt;&gt; ] ]
  ;
  patt_term_eos:
    [ [ x = patt_term; EOS -&gt; x ] ]
  ;
  patt_term:
    [ [ BSLASH; i = IDENT; &quot;.&quot;; t = SELF -&gt; &lt;:patt&lt; Lam $str:i$ $t$ &gt;&gt; ]
    | [ x = SELF; y = SELF -&gt; &lt;:patt&lt; App $x$ $y$ &gt;&gt; ]
    | [ i = IDENT -&gt; &lt;:patt&lt; Var $str:i$ &gt;&gt;
      | CARET; r = patt_antiquot -&gt; r
      | &quot;(&quot;; t = SELF; &quot;)&quot; -&gt; t ] ]
  ;
  patt_antiquot:
    [ [ i = IDENT -&gt;
         let r =
           let loc = Ploc.make_unlined (0, String.length i) in
           &lt;:patt&lt; $lid:i$ &gt;&gt;
         in
         &lt;:patt&lt; $anti:r$ &gt;&gt; ] ]
  ;
END;

value expand_expr s =
  Grammar.Entry.parse expr_term_eos (Stream.of_string s)
;
value expand_patt s =
  Grammar.Entry.parse patt_term_eos (Stream.of_string s)
;

Quotation.add &quot;term&quot; (Quotation.ExAst (expand_expr, expand_patt));
Quotation.default.val := &quot;term&quot;;
</pre></div>
</div>
<p class="rubric" id="compilation-and-test">Compilation and test</p>
<p>Compilation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="o">-</span><span class="n">c</span> <span class="n">term</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>Example, in the toplevel, including a semantic error, correctly
underlined, thanks to the antiquotation nodes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ocaml -I +camlp5 camlp5r.cma
        Objective Caml version ...

        Camlp5 Parsing version ...

# #load &quot;term.cmo&quot;;
# type term =
   [ Lam of string and term
   | App of term and term
   |   Var of string ]
  ;
type term =
  [ Lam of string and term | App of term and term | Var of string ]
# value comb_s = &lt;&lt; \x.\y.\z.(x y)(x z) &gt;&gt;;
value comb_s : term =
  Lam &quot;x&quot;
   (Lam &quot;y&quot;
     (Lam &quot;z&quot; (App (App (Var &quot;x&quot;) (Var &quot;y&quot;)) (App (Var &quot;x&quot;) (Var &quot;z&quot;)))))
# value omega = &lt;&lt; ^delta ^delta &gt;&gt;;
Characters 18-23:
  value omega = &lt;&lt; ^delta ^delta &gt;&gt;;
                    ^^^^^
Unbound value delta
# value delta = &lt;&lt; \x.x x &gt;&gt;;
value delta : term = Lam &quot;x&quot; (App (Var &quot;x&quot;) (Var &quot;x&quot;))
# value omega = &lt;&lt; ^delta ^delta &gt;&gt;;
value omega : term =
  App (Lam &quot;x&quot; (App (Var &quot;x&quot;) (Var &quot;x&quot;)))
    (Lam &quot;x&quot; (App (Var &quot;x&quot;) (Var &quot;x&quot;)))
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="revsynt.html" class="btn btn-neutral float-right" title="The revised syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="redef.html" class="btn btn-neutral float-left" title="Redefining OCaml syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2007-2017, INRIA (Institut National de Recherches en Informatique et Automatique). All rights reserved.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>