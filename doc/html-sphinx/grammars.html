

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extensible grammars &mdash; Camlp5  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parsing tools" href="printing-tools.html" />
    <link rel="prev" title="Backtracking parsers" href="bparsers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Camlp5
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="strict.html">Transitional and Strict modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ptools.html">Parsing and Printing tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="parsing-tools.html">Printing tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="parsers.html">Stream parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexers.html">Stream lexers</a></li>
<li class="toctree-l2"><a class="reference internal" href="fparsers.html">Functional parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="bparsers.html">Backtracking parsers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Extensible grammars</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="printing-tools.html">Parsing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-extensions.html">Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Future work</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Camlp5</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="parsing-tools.html">Printing tools</a> &raquo;</li>
        
      <li>Extensible grammars</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/camlp5/camlp5/blob/master/doc/rstgrammars.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="extensible-grammars">
<h1>Extensible grammars<a class="headerlink" href="#extensible-grammars" title="Permalink to this headline">¶</a></h1>
<div class="docutils container" id="content">
<p class="top rubric" id="id1">Extensible grammars</p>
<p>This chapter describes the syntax and semantics of the extensible
grammars of Camlp5.</p>
<p>The extensible grammars are the most advanced parsing tool of Camlp5.
They apply to streams of characters using a lexer which has to be
previously defined by the programmer. In Camlp5, the syntax of the
OCaml language is defined with extensible grammars, which makes
Camlp5 a bootstrapped system (it compiles its own features by
itself).</p>
<p class="rubric" id="getting-started">Getting started</p>
<p>The extensible grammars are a system to build <em>grammar entries</em> which
can be extended dynamically. A grammar entry is an abstract value
internally containing a stream parser. The type of a grammar entry is
<code class="docutils literal"><span class="pre">&quot;Grammar.Entry.e</span> <span class="pre">t&quot;</span></code> where <code class="docutils literal"><span class="pre">&quot;t&quot;</span></code> is the type of the values
returned by the grammar entry.</p>
<p>To start with extensible grammars, it is necessary to build a
<em>grammar</em>, a value of type “<code class="docutils literal"><span class="pre">Grammar.g</span></code>”, using the function
“<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="n">lexer</span><span class="p">;</span>
</pre></div>
</div>
<p>where “<code class="docutils literal"><span class="pre">lexer</span></code>” is a lexer previously defined. See the section
explaining the interface with lexers. In a first time, it is possible
to use a lexer of the module “<code class="docutils literal"><span class="pre">Plexer</span></code>” provided by Camlp5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="p">(</span><span class="n">Plexer</span><span class="o">.</span><span class="n">gmake</span> <span class="p">());</span>
</pre></div>
</div>
<p>Each grammar entry is associated with a grammar. Only grammar entries
of the same grammar can call each other. To create a grammar entry,
one has to use the function “<code class="docutils literal"><span class="pre">Grammar.Entry.create</span></code>” with takes the
grammar as first parameter and a name as second parameter. This name
is used in case of syntax errors. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;expression&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>To apply a grammar entry, the function “<code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code>” can
be used. Its first parameter is the grammar entry, the second one a
stream of characters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">exp</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="s2">&quot;hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>But if you experiment this, since the entry was just created without
any rules, you receive an error message:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Stream</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;entry [expression] is empty&quot;</span>
</pre></div>
</div>
<p>To add grammar rules to the grammar entry, it is necessary to
<em>extend</em> it, using a specific syntactic statement: “<code class="docutils literal"><span class="pre">EXTEND</span></code>”.</p>
<p class="rubric" id="syntax-of-the-extend-statement">Syntax of the EXTEND statement</p>
<p>The “<code class="docutils literal"><span class="pre">EXTEND</span></code>” statement is added in the expressions of the OCaml
language when the syntax extension kit “<code class="docutils literal"><span class="pre">pa_extend.cmo</span></code>” is loaded.
Its syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">expression</span> <span class="p">:</span><span class="o">:=</span> <span class="n">extend</span>
      <span class="n">extend</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;EXTEND&quot;</span> <span class="n">extend</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
 <span class="n">extend</span><span class="o">-</span><span class="n">body</span> <span class="p">:</span><span class="o">:=</span> <span class="k">global</span><span class="o">-</span><span class="n">opt</span> <span class="n">entries</span>
  <span class="k">global</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;GLOBAL&quot;</span> <span class="s2">&quot;:&quot;</span> <span class="n">entry</span><span class="o">-</span><span class="n">names</span> <span class="s2">&quot;;&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
 <span class="n">entry</span><span class="o">-</span><span class="n">names</span> <span class="p">:</span><span class="o">:=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="n">entry</span><span class="o">-</span><span class="n">names</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span>
       <span class="n">entry</span> <span class="p">:</span><span class="o">:=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;:&quot;</span> <span class="n">position</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">levels</span> <span class="s2">&quot;]&quot;</span>
<span class="n">position</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;FIRST&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;LAST&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;BEFORE&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;AFTER&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;LIKE&quot;</span> <span class="n">string</span>
               <span class="o">|</span> <span class="s2">&quot;LEVEL&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
      <span class="n">levels</span> <span class="p">:</span><span class="o">:=</span> <span class="n">level</span> <span class="s2">&quot;|&quot;</span> <span class="n">levels</span>
               <span class="o">|</span> <span class="n">level</span>
       <span class="n">level</span> <span class="p">:</span><span class="o">:=</span> <span class="n">label</span><span class="o">-</span><span class="n">opt</span> <span class="n">assoc</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
   <span class="n">label</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="n">label</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
   <span class="n">assoc</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;LEFTA&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;RIGHTA&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;NONA&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
       <span class="n">rules</span> <span class="p">:</span><span class="o">:=</span> <span class="n">rule</span> <span class="s2">&quot;|&quot;</span> <span class="n">rules</span>
               <span class="o">|</span> <span class="n">rule</span>
        <span class="n">rule</span> <span class="p">:</span><span class="o">:=</span> <span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
               <span class="o">|</span> <span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span>
<span class="n">psymbols</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="n">psymbols</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
    <span class="n">psymbols</span> <span class="p">:</span><span class="o">:=</span> <span class="n">psymbol</span> <span class="s2">&quot;;&quot;</span> <span class="n">psymbols</span>
               <span class="o">|</span> <span class="n">psymbol</span>
     <span class="n">psymbol</span> <span class="p">:</span><span class="o">:=</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">symbol</span>
      <span class="n">symbol</span> <span class="p">:</span><span class="o">:=</span> <span class="n">keyword</span>
               <span class="o">|</span> <span class="n">token</span>
               <span class="o">|</span> <span class="n">token</span> <span class="n">string</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span>
               <span class="o">|</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;LEVEL&quot;</span> <span class="n">label</span>
               <span class="o">|</span> <span class="s2">&quot;SELF&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;NEXT&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;LIST0&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;LIST0&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span>
               <span class="o">|</span> <span class="s2">&quot;LIST1&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;LIST1&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span>
               <span class="o">|</span> <span class="s2">&quot;OPT&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;FLAG&quot;</span> <span class="n">symbol</span>
               <span class="o">|</span> <span class="s2">&quot;V&quot;</span> <span class="n">symbol</span> <span class="n">opt</span><span class="o">-</span><span class="n">strings</span>
               <span class="o">|</span> <span class="s2">&quot;[&quot;</span> <span class="n">rules</span> <span class="s2">&quot;]&quot;</span>
               <span class="o">|</span> <span class="s2">&quot;(&quot;</span> <span class="n">symbol</span> <span class="s2">&quot;)&quot;</span>
 <span class="n">opt</span><span class="o">-</span><span class="n">opt</span><span class="o">-</span><span class="n">sep</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;OPT_SEP&quot;</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
 <span class="n">opt</span><span class="o">-</span><span class="n">strings</span> <span class="p">:</span><span class="o">:=</span> <span class="n">string</span> <span class="n">opt</span><span class="o">-</span><span class="n">strings</span>
               <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
     <span class="n">keyword</span> <span class="p">:</span><span class="o">:=</span> <span class="n">string</span>
       <span class="n">token</span> <span class="p">:</span><span class="o">:=</span> <span class="n">uident</span>
       <span class="n">label</span> <span class="p">:</span><span class="o">:=</span> <span class="n">string</span>
  <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="p">:</span><span class="o">:=</span> <span class="n">qualid</span>
      <span class="n">qualid</span> <span class="p">:</span><span class="o">:=</span> <span class="n">qualid</span> <span class="s2">&quot;.&quot;</span> <span class="n">qualid</span>
               <span class="o">|</span> <span class="n">uident</span>
               <span class="o">|</span> <span class="n">lident</span>
      <span class="n">uident</span> <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;A&#39;</span><span class="o">-</span><span class="s1">&#39;Z&#39;</span> <span class="n">ident</span>
      <span class="n">lident</span> <span class="p">:</span><span class="o">:=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">-</span><span class="s1">&#39;z&#39;</span> <span class="o">|</span> <span class="s1">&#39;_&#39;</span> <span class="o">|</span> <span class="n">misc</span><span class="o">-</span><span class="n">letter</span><span class="p">)</span> <span class="n">ident</span>
       <span class="n">ident</span> <span class="p">:</span><span class="o">:=</span> <span class="n">ident</span><span class="o">-</span><span class="n">char</span><span class="o">*</span>
  <span class="n">ident</span><span class="o">-</span><span class="n">char</span> <span class="p">:</span><span class="o">:=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">-</span><span class="s1">&#39;a&#39;</span> <span class="o">|</span> <span class="s1">&#39;A&#39;</span><span class="o">-</span><span class="s1">&#39;Z&#39;</span> <span class="o">|</span> <span class="s1">&#39;0&#39;</span><span class="o">-</span><span class="s1">&#39;9&#39;</span> <span class="o">|</span> <span class="s1">&#39;_&#39;</span> <span class="o">|</span> <span class="s1">&#39;&#39;&#39; | misc-letter)</span>
<span class="s1"> misc-letter ::= &#39;</span><span class="se">\12</span><span class="s1">8&#39;-&#39;</span><span class="se">\255</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>Other statements, “<code class="docutils literal"><span class="pre">GEXTEND</span></code>”, “<code class="docutils literal"><span class="pre">DELETE_RULE</span></code>”,
“<code class="docutils literal"><span class="pre">GDELETE_RULE</span></code>” are also defined by the same syntax extension kit.
See further.</p>
<p>In the description above, only “<code class="docutils literal"><span class="pre">EXTEND</span></code>” and “<code class="docutils literal"><span class="pre">END</span></code>” are new
keywords (reserved words which cannot be used in variables,
constructors or module names). The other strings (e.g. “<code class="docutils literal"><span class="pre">GLOBAL</span></code>”,
“<code class="docutils literal"><span class="pre">LEVEL</span></code>”, “<code class="docutils literal"><span class="pre">LIST0</span></code>”, “<code class="docutils literal"><span class="pre">LEFTA</span></code>”, etc.) are not reserved.</p>
<p class="rubric" id="semantics-of-the-extend-statement">Semantics of the EXTEND statement</p>
<p>The EXTEND statement starts with the “<code class="docutils literal"><span class="pre">EXTEND</span></code>” keyword and ends
with the “<code class="docutils literal"><span class="pre">END</span></code>” keyword.</p>
<p class="rubric" id="global-indicator">GLOBAL indicator</p>
<p>After the first keyword, it is possible to see the identifier
“<code class="docutils literal"><span class="pre">GLOBAL</span></code>” followed by a colon, a list of entries names and a
semicolon. It says that these entries correspond to visible
(previously defined) entry variables, in the context of the EXTEND
statement, the other ones being locally and silently defined inside.</p>
<ul class="simple">
<li>If an entry, which is extended in the EXTEND statement, is in the
GLOBAL list, but is not defined in the context of the EXTEND
statement, the OCaml compiler will fail with the error “unbound
value”.</li>
<li>If there is no GLOBAL indicator, and an entry, which is extended
in the EXTEND statement, is not defined in the contex of the
EXTEND statement, the OCaml compiler will also fail with the error
“unbound value”.</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;exp&quot;</span><span class="p">;</span>
<span class="n">EXTEND</span>
  <span class="n">GLOBAL</span><span class="p">:</span> <span class="n">exp</span><span class="p">;</span>
  <span class="n">exp</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">bar</span> <span class="p">]</span> <span class="p">];</span>
  <span class="n">foo</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="s2">&quot;foo&quot;</span> <span class="p">]</span> <span class="p">];</span>
  <span class="n">bar</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span> <span class="s2">&quot;bar&quot;</span> <span class="p">]</span> <span class="p">];</span>
<span class="n">END</span><span class="p">;</span>
</pre></div>
</div>
<p>The entry “exp” is an existing variable (defined by value exp = …).
On the other hand, the entries “foo” and “bar” have not been defined.
Because of the GLOBAL indicator, the system define them locally.</p>
<p>Without the GLOBAL indicator, the three entries would have been
considered as global variables, therefore the OCaml compiler would
say “unbound variable” under the first undefined entry, “foo”.</p>
<p class="rubric" id="entries-list">Entries list</p>
<p>Then the list of entries extensions follow. An entry extension starts
with the entry name followed by a colon. An entry may have several
levels corresponding to several stream parsers which call the ones
the others (see further).</p>
<p class="rubric" id="optional-position">Optional position</p>
<p>After the colon, it is possible to specify a where to insert the
defined levels:</p>
<ul class="simple">
<li>The identifier “<code class="docutils literal"><span class="pre">FIRST</span></code>” (resp. “<code class="docutils literal"><span class="pre">LAST</span></code>”) indicates that the
level must be inserted before (resp. after) all possibly existing
levels of the entry. They become their first (resp. last) levels.</li>
<li>The identifier “<code class="docutils literal"><span class="pre">BEFORE</span></code>” (resp. “<code class="docutils literal"><span class="pre">AFTER</span></code>”) followed by a
level label (a string) indicates that the levels must be inserted
before (resp. after) that level, if it exists. If it does not
exist, the extend statement fails at run time.</li>
<li>The identifier “<code class="docutils literal"><span class="pre">LIKE</span></code>” followed by a string indicates that the
first level defined in the extend statement must be inserted in
the first already existing level with a rule containing this
string as keyword or token name. For example, “<code class="docutils literal"><span class="pre">LIKE</span> <span class="pre">&quot;match&quot;</span></code>”
is the first level having “<code class="docutils literal"><span class="pre">match</span></code>” as keyword. If there is no
level with this string, the extend statement fails at run time.</li>
<li>The identifier “<code class="docutils literal"><span class="pre">LEVEL</span></code>” followed by a level label indicates
that the first level defined in the extend statement must be
inserted at the given level, extending and modifying it. The other
levels defined in the statement are inserted after this level, and
before the possible levels following this level. If there is no
level with this label, the extend statement fails at run time.</li>
<li>By default, if the entry has no level, the levels defined in the
statement are inserted in the entry. Otherwise the first defined
level is inserted at the first level of the entry, extending or
modifying it. The other levels are inserted afterwards (before the
possible second level which may previously exist in the entry).</li>
</ul>
<p class="rubric" id="levels">Levels</p>
<p>After the optional “position”, the <em>level</em> list follow. The levels
are separated by vertical bars, the whole list being between
brackets.</p>
<p>A level starts with an optional label, which corresponds to its name.
This label is useful to specify this level in case of future
extensions, using the <em>position</em> (see previous section) or for
possible direct calls to this specific level.</p>
<p>The level continues with an optional associativity indicator, which
can be:</p>
<ul class="simple">
<li>LEFTA for left associativity (default),</li>
<li>RIGHTA for right associativity,</li>
<li>NONA for no associativity.</li>
</ul>
<p class="rubric" id="rules">Rules</p>
<p>At last, the grammar <em>rule</em> list appear. The rules are separated by
vertical bars, the whole list being brackets.</p>
<p>A rule looks like a match case in the “<code class="docutils literal"><span class="pre">match</span></code>” statement or a
parser case in the “<code class="docutils literal"><span class="pre">parser</span></code>” statement: a list of psymbols (see
next paragraph) separated by semicolons, followed by a right arrow
and an expression, the semantic action. Actually, the right arrow and
expression are optional: in this case, it is equivalent to an
expression which would be the unit “<code class="docutils literal"><span class="pre">()</span></code>” constructor.</p>
<p>A psymbol is either a pattern, followed with the equal sign and a
symbol, or by a symbol alone. It corresponds to a test of this
symbol, whose value is bound to the pattern if any.</p>
<p class="rubric" id="symbols">Symbols</p>
<p>A symbol is an item in a grammar rule. It is either:</p>
<ul class="simple">
<li>a keyword (a string): the input must match this keyword,</li>
<li>a token name (an identifier starting with an uppercase character),
optionally followed by a string: the input must match this token
(any value if no string, or that string if a string follows the
token name), the list of the available tokens depending on the
associated lexer (the list of tokens available with “Plexer.gmake
()” is: LIDENT, UIDENT, TILDEIDENT, TILDEIDENTCOLON,
QUESTIONIDENT, INT, INT_l, INT_L, INT_n, FLOAT, CHAR, STRING,
QUOTATION, ANTIQUOT and EOI; other lexers may propose other lists
of tokens),</li>
<li>an entry name, which correspond to a call to this entry,</li>
<li>an entry name followed by the identifier “<code class="docutils literal"><span class="pre">LEVEL</span></code>” and a level
label, which correspond to the call to this entry at that level,</li>
<li>the identifier “<code class="docutils literal"><span class="pre">SELF</span></code>” which is a recursive call to the present
entry, according to the associativity (i.e. it may be a call at
the current level, to the next level, or to the top level of the
entry): “<code class="docutils literal"><span class="pre">SELF</span></code>” is equivalent to the name of the entry itself,</li>
<li>the identifier “<code class="docutils literal"><span class="pre">NEXT</span></code>”, which is a call to the next level of
the current entry,</li>
<li>a left brace, followed by a list of rules separated by vertical
bars, and a right brace: equivalent to a call to an entry, with
these rules, inlined,</li>
<li>a meta symbol (see further),</li>
<li>a symbol between parentheses.</li>
</ul>
<p>The syntactic analysis follow the list of symbols. If it fails,
depending on the first items of the rule (see the section about the
kind of grammars recognized):</p>
<ul class="simple">
<li>the parsing may fail by raising the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>”</li>
<li>the parsing may continue with the next rule.</li>
</ul>
<p class="rubric" id="meta-symbols">Meta symbols</p>
<p>Extra symbols exist, allowing to manipulate lists or optional
symbols. They are:</p>
<ul class="simple">
<li>LIST0 followed by a symbol: this is a list of this symbol,
possibly empty,</li>
<li>LIST0 followed by a symbol, SEP and another symbol, and optional
OPT_SEP: this is a list, possibly empty, of the first symbol
separated by the second one, possibly ended with the separator if
OPT_SEP is present,</li>
<li>LIST1 followed by a symbol: this is a list of this symbol, with at
least one element,</li>
<li>LIST1 followed by a symbol, SEP and another symbol, and optional
OPT_SEP: this is a list, with at least one element, of the first
symbol separated by the second one, possibly ended with the
separator if OPT_SEP is present,</li>
<li>OPT followed by a symbol: equivalent to “this symbol or nothing”
returning a value of type “<code class="docutils literal"><span class="pre">option</span></code>”.</li>
<li>FLAG followed by a symbol: equivalent to “this symbol or nothing”,
returning a boolean.</li>
</ul>
<p class="rubric" id="the-v-meta-symbol">The V meta symbol</p>
<p>The V meta symbol is destinated to allow antiquotations while using
the syntax tree quotation kit <code class="docutils literal"><span class="pre">`q_ast.cmo</span></code> &lt;q_ast.html&gt;`__. It
works only in strict mode. In transitional mode, it is just
equivalent to its symbol parameter.</p>
<p class="rubric" id="antiquotation-kind">Antiquotation kind</p>
<p>The antiquotation kind is the optional identifier between the
starting “<code class="docutils literal"><span class="pre">$</span></code>” (dollar) and the “<code class="docutils literal"><span class="pre">:</span></code>” (colon) in a quotation of
syntax tree (see the chapter <a class="reference external" href="ml_ast.html">syntax tree</a>).</p>
<p>The optional list of strings following the “V” meta symbol and its
symbol parameter gives the allowed antiquotations kinds.</p>
<p>By default, this string list, i.e. the available antiquotation kinds,
is:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[&quot;flag&quot;]</span></code> for FLAG</li>
<li><code class="docutils literal"><span class="pre">[&quot;list&quot;]</span></code> for LIST0 and LIST1</li>
<li><code class="docutils literal"><span class="pre">[&quot;opt&quot;]</span></code> for OPT</li>
</ul>
<p>For example, the symbol:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="p">(</span><span class="n">FLAG</span> <span class="s2">&quot;rec&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>is like “FLAG” while normally parsing, allowing to parse the keyword
“<code class="docutils literal"><span class="pre">rec</span></code>”. While using it in quotations, also allows the parse the
keyword “<code class="docutils literal"><span class="pre">rec</span></code>” but, moreover, the antiquotation “<code class="docutils literal"><span class="pre">$flag:..$</span></code>”
where “<code class="docutils literal"><span class="pre">..</span></code>” is an expression or a pattern depending on the
position of the quotation.</p>
<p>There are also default antiquotations kinds for the tokens used in
the OCaml language predefined parsers “<code class="docutils literal"><span class="pre">pa_r.cmo</span></code>” (revised syntax)
and “<code class="docutils literal"><span class="pre">pa_o.cmo</span></code>” (normal syntax), actually all parsers using the
provided lexer “<code class="docutils literal"><span class="pre">Plexer</span></code>” (see the chapter
<a class="reference external" href="library.html">Library</a>). They are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[&quot;chr&quot;]</span></code> for CHAR</li>
<li><code class="docutils literal"><span class="pre">[&quot;flo&quot;]</span></code> for FLOAT</li>
<li><code class="docutils literal"><span class="pre">[&quot;int&quot;]</span></code> for INT</li>
<li><code class="docutils literal"><span class="pre">[&quot;int32&quot;]</span></code> for INT_l</li>
<li><code class="docutils literal"><span class="pre">[&quot;int64&quot;]</span></code> for INT_L</li>
<li><code class="docutils literal"><span class="pre">[&quot;nativeint&quot;]</span></code> for INT_n</li>
<li><code class="docutils literal"><span class="pre">[&quot;lid&quot;]</span></code> for LIDENT</li>
<li><code class="docutils literal"><span class="pre">[&quot;str&quot;]</span></code> for STRING</li>
<li><code class="docutils literal"><span class="pre">[&quot;uid&quot;]</span></code> for UIDENT</li>
</ul>
<p>It is also possible to use the “V” meta symbol over non-terminals
(grammars entries), but there is no default antiquotation kind. For
example, while parsing a quotation, the symbol:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="n">foo</span> <span class="s2">&quot;bar&quot;</span> <span class="s2">&quot;oops&quot;</span>
</pre></div>
</div>
<p>corresponds to either a call to the grammar entry “<code class="docutils literal"><span class="pre">foo</span></code>”, or to
the antiquotations “<code class="docutils literal"><span class="pre">$bar:...$</span></code>” or “<code class="docutils literal"><span class="pre">$oops:...$</span></code>”.</p>
<p class="rubric" id="type">Type</p>
<p>The type of the value returned by a V meta symbol is:</p>
<ul class="simple">
<li>in transitional mode, the type of its symbol parameter,</li>
<li>in strict mode, “<code class="docutils literal"><span class="pre">Ploc.vala</span> <span class="pre">t</span></code>”, where “<code class="docutils literal"><span class="pre">t</span></code>” is its symbol
parameter.</li>
</ul>
<p>In strict mode, if the symbol parameter is found, whose value is,
say, “<code class="docutils literal"><span class="pre">x</span></code>”, the result is “<code class="docutils literal"><span class="pre">Ploc.VaVal</span> <span class="pre">x</span></code>”. If an antiquotation
is found the result is “<code class="docutils literal"><span class="pre">Ploc.VaAnt</span> <span class="pre">s</span></code>” where “<code class="docutils literal"><span class="pre">s</span></code>” is some
string containing the antiquotation text and some other internal
information.</p>
<p class="rubric" id="rules-insertion">Rules insertion</p>
<p>Remember that “<code class="docutils literal"><span class="pre">EXTEND</span></code>” is a statement, not a declaration: the
rules are added in the entries at run time. Each rule is internally
inserted in a tree, allowing the left factorization of the rule. For
example, with this list of rules (borrowed from the Camlp5 sources):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;virtual&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="s2">&quot;private&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">fun_binding</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="s2">&quot;:&quot;</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">poly_type</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">expr</span>
<span class="s2">&quot;method&quot;</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">fun_binding</span>
</pre></div>
</div>
<p>the rules are inserted in a tree and the result looks like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;method&quot;</span>
   <span class="o">|--</span> <span class="s2">&quot;private&quot;</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="s2">&quot;virtual&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>       <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>             <span class="o">|</span>    <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>             <span class="o">|</span>            <span class="o">|--</span> <span class="s2">&quot;:=&quot;</span>
   <span class="o">|</span>             <span class="o">|</span>                 <span class="o">|--</span> <span class="n">expr</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="n">fun_binding</span>
   <span class="o">|--</span> <span class="s2">&quot;virtual&quot;</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="s2">&quot;private&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>       <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>       <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|</span>       <span class="o">|--</span> <span class="n">label</span>
   <span class="o">|</span>             <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
   <span class="o">|</span>                  <span class="o">|--</span> <span class="n">poly_type</span>
   <span class="o">|--</span> <span class="n">label</span>
         <span class="o">|--</span> <span class="s2">&quot;:&quot;</span>
         <span class="o">|</span>    <span class="o">|--</span> <span class="n">poly_type</span>
         <span class="o">|</span>            <span class="o">|--</span> <span class="s2">&quot;=&quot;</span>
         <span class="o">|</span>                 <span class="o">|--</span> <span class="n">expr</span>
         <span class="o">|--</span> <span class="n">fun_binding</span>
</pre></div>
</div>
<p>This tree is built as long as rules are inserted. When used, by
applying the function “<code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code>” to the current entry,
the input is matched with that tree, starting from the tree root,
descending on it as long as the parsing advances.</p>
<p>There is a different tree by entry level.</p>
<p class="rubric" id="semantic-action">Semantic action</p>
<p>The semantic action, i.e. the expression following the right arrow in
rules, contains in its environment:</p>
<ul class="simple">
<li>the variables bound by the patterns of the symbols found in the
rules,</li>
<li>the specific variable “<code class="docutils literal"><span class="pre">loc</span></code>” which contain the location of the
whole rule in the source.</li>
</ul>
<p>The location is an abstract type defined in the module “<code class="docutils literal"><span class="pre">Ploc</span></code>” of
Camlp5.</p>
<p>It is possible to change the name of this variable by using the
option “<code class="docutils literal"><span class="pre">-loc</span></code>” of Camlp5. For example, compiling a file like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5r</span> <span class="o">-</span><span class="n">loc</span> <span class="n">foobar</span> <span class="n">file</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>the variable name, for the location will be “<code class="docutils literal"><span class="pre">foobar</span></code>” instead of
“<code class="docutils literal"><span class="pre">loc</span></code>”.</p>
<p class="rubric" id="the-delete-rule-statement">The DELETE_RULE statement</p>
<p>The “<code class="docutils literal"><span class="pre">DELETE_RULE</span></code>” statement is also added in the expressions of
the OCaml language when the syntax extension kit “<code class="docutils literal"><span class="pre">pa_extend.cmo</span></code>”
is loaded. Its syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="n">expression</span> <span class="p">:</span><span class="o">:=</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span>
     <span class="n">delete</span><span class="o">-</span><span class="n">rule</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;DELETE_RULE&quot;</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
<span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="p">:</span><span class="o">:=</span> <span class="n">entry</span><span class="o">-</span><span class="n">name</span> <span class="s2">&quot;:&quot;</span> <span class="n">symbols</span>
         <span class="n">symbols</span> <span class="p">:</span><span class="o">:=</span> <span class="n">symbol</span> <span class="n">symbols</span>
                   <span class="o">|</span> <span class="n">symbol</span>
</pre></div>
</div>
<p>See the syntax of the EXTEND statement for the meaning of the syntax
entries not defined above.</p>
<p>The entry is scanned for a rule matching the giving symbol list. When
found, the rule is removed. If no rule is found, the exception
“<code class="docutils literal"><span class="pre">Not_found</span></code>” is raised.</p>
<p class="rubric" id="extensions-fold0-and-fold1">Extensions FOLD0 and FOLD1</p>
<p>When loading “<code class="docutils literal"><span class="pre">pa_extfold.cmo</span></code>” after “<code class="docutils literal"><span class="pre">pa_extend.cmo</span></code>”, the
entry “<code class="docutils literal"><span class="pre">symbol</span></code>” of the EXTEND statement is extended with what is
named the <em>fold iterators</em>, like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>     <span class="n">symbol</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;FOLD0&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD1&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD0&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span>
              <span class="o">|</span> <span class="s2">&quot;FOLD1&quot;</span> <span class="n">simple_expr</span> <span class="n">simple_expr</span> <span class="n">symbol</span> <span class="s2">&quot;SEP&quot;</span> <span class="n">symbol</span>
<span class="n">simple_expr</span> <span class="p">:</span><span class="o">:=</span> <span class="n">expr</span> <span class="p">(</span><span class="n">level</span> <span class="s2">&quot;simple&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Like their equivalent with the lists iterators: “<code class="docutils literal"><span class="pre">LIST0</span></code>”,
“<code class="docutils literal"><span class="pre">LIST1</span></code>”, “<code class="docutils literal"><span class="pre">LIST0SEP</span></code>”, “<code class="docutils literal"><span class="pre">LIST1SEP</span></code>”, they read a sequence of
symbols, possibly with the separators, but instead of building the
list of these symbols, apply a fold function to each symbol, starting
at the second “expr” (which must be a expression node) and continuing
with the first “expr” (which must be a function taking two
expressions and returing a new expression).</p>
<p>The list iterators can be seen almost as a specific case of these
fold iterators where the initial “expr” would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="p">:</span><span class="n">expr</span><span class="o">&lt;</span> <span class="p">[]</span> <span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>and the fold function would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>fun e1 e2 -&gt; &lt;:expr&lt; [$e1$ :: $e2$ ] &gt;&gt;
</pre></div>
</div>
<p>except that, implemented like that, they would return the list in
reverse order.</p>
<p>Actually, a program using them can be written with the lists
iterators with the semantic action applying the function
“<code class="docutils literal"><span class="pre">List.fold_left</span></code>” to the returned list, except that with the fold
iterators, this operation is done as long as the symbols are read on
the input, no intermediate list being built.</p>
<p>Example, file “sum.ml”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#load &quot;pa_extend.cmo&quot;;
#load &quot;pa_extfold.cmo&quot;;
#load &quot;q_MLast.cmo&quot;;
let loc = Ploc.dummy in
EXTEND
  Pcaml.expr:
    [ [ &quot;sum&quot;;
        e =
          FOLD0 (fun e1 e2 -&gt; &lt;:expr&lt; $e2$ + $e1$ &gt;&gt;) &lt;:expr&lt; 0 &gt;&gt;
            Pcaml.expr SEP &quot;;&quot;;
        &quot;end&quot; -&gt; e ] ]
  ;
END;
</pre></div>
</div>
<p>which can be compiled like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="o">-</span><span class="n">c</span> <span class="nb">sum</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>and tested:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">ocaml</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="n">camlp5r</span><span class="o">.</span><span class="n">cma</span> <span class="nb">sum</span><span class="o">.</span><span class="n">cmo</span>
          <span class="n">Objective</span> <span class="n">Caml</span> <span class="n">version</span> <span class="o">...</span>

          <span class="n">Camlp5</span> <span class="n">Parsing</span> <span class="n">version</span> <span class="o">...</span>

  <span class="c1"># sum 3;4;5 end;</span>
<span class="o">-</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
<p class="rubric" id="grammar-machinery">Grammar machinery</p>
<p>We explain here the detail of the mechanism of the parsing of an
entry.</p>
<p class="rubric" id="start-and-continue">Start and Continue</p>
<p>At each entry level, the rules are separated into two trees:</p>
<ul class="simple">
<li>The tree of the rules <em>not</em> starting with the current entry name
nor by “<code class="docutils literal"><span class="pre">SELF</span></code>”.</li>
<li>The tree of the rules starting with the current entry name or by
the identifier “<code class="docutils literal"><span class="pre">SELF</span></code>”, this symbol not being included in the
tree.</li>
</ul>
<p>They determine two functions:</p>
<ul class="simple">
<li>The function named “start”, analyzing the first tree.</li>
<li>The function named “continue”, taking, as parameter, a value
previously parsed, and analyzing the second tree.</li>
</ul>
<p>A call to an entry, using “<code class="docutils literal"><span class="pre">Grammar.Entry.parse</span></code>” correspond to a
call to the “start” function of the first level of the entry.</p>
<p>The “start” function tries its associated tree. If it works, it calls
the “continue” function of the same level, giving the result of
“start” as parameter. If this “continue” function fails, this
parameter is simply returned. If the “start” function fails, the
“start” function of the next level is tested. If there is no more
levels, the parsing fails.</p>
<p>The “continue” function first tries the “continue” function of the
next level. If it fails, or if it is the last level, it tries its
associated tree, then calls itself again, giving the result as
parameter. If its associated tree fails, it returns its extra
parameter.</p>
<p class="rubric" id="associativity">Associativity</p>
<p>While testing the tree, there is a special case for rules ending with
SELF or with the current entry name. For this last symbol, there is a
call to the “start” function: of the current level if the level is
right associative, or of the next level otherwise.</p>
<p>There is no behaviour difference between left and non associative,
because, in case of syntax error, the system attempts to recover the
error by applying the “continue” function of the previous symbol (if
this symbol is a call to an entry).</p>
<p>When a SELF or the current entry name is encountered in the middle
of the rule (i.e. if it is neither the first nor the last symbol),
there is a call to the “start” function of the first level of the
current entry.</p>
<p>Example. Let us consider the following grammar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">EXTEND</span>
  <span class="n">expr</span><span class="p">:</span>
    <span class="p">[</span> <span class="s2">&quot;minus&quot;</span> <span class="n">LEFTA</span>
      <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;-&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SELF</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-.</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="s2">&quot;power&quot;</span> <span class="n">RIGHTA</span>
      <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;**&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">SELF</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">**</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="s2">&quot;simple&quot;</span>
      <span class="p">[</span> <span class="s2">&quot;(&quot;</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;)&quot;</span> <span class="o">-&gt;</span> <span class="n">x</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">INT</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">x</span> <span class="p">]</span> <span class="p">]</span>
  <span class="p">;</span>
<span class="n">END</span>
</pre></div>
</div>
<p>The left “SELF”s of the two levels “minus” and “power” correspond to
a call to the next level. In the level “minus”, the right “SELF”
also, and the left associativity is treated by the fact that the
“continue” function is called (starting with the keyword “-” since
the left “SELF” is not part of the tree). On the other hand, for the
level “power”, the right “SELF” corresponds to a call to the current
level, i.e. the level “power” again. At end, the “SELF” between
parentheses of the level “simple” correspond to a call to the first
level, namely “minus” in this grammar.</p>
<p class="rubric" id="parsing-algorithm">Parsing algorithm</p>
<p>By default, the kind of grammar is predictive parsing grammar, i.e.
recursive descent parsing without backtrack. But with some nuances,
due to the improvements (error recovery and token starting rules)
indicated in the next sections.</p>
<p>However, it is possible to change the parsing algorithm, by calling
the function “<code class="docutils literal"><span class="pre">Grammar.set_algorithm</span></code>”. The possible values are:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Grammar.Predictive</span></code></dt>
<dd>internally using <a class="reference external" href="parsers.html">normal parsers</a>, with a
predictive (recursive descent without backtracking) algorithm.</dd>
<dt><code class="docutils literal"><span class="pre">Grammar.Functional</span></code></dt>
<dd>internally using <a class="reference external" href="fparsers.html">functional parsers</a>, with a
limited backtracking algorithm,</dd>
<dt><code class="docutils literal"><span class="pre">Grammar.Backtracking</span></code></dt>
<dd>internally using <a class="reference external" href="bparsers.html">backtracking parsers</a>, with a
full backtracking algorithm,</dd>
<dt><code class="docutils literal"><span class="pre">Grammar.DefaultAlgorithm</span></code></dt>
<dd>the parsing algorithm is determined by the environment variable
“CAMLP5PARAM”. If this environment variable exists and contains
“f”, the parsing algorithm is “functional”; if it it “b”, the
parsing algorithm is “backtracking”. Otherwise it is “predictive”.</dd>
</dl>
<p>An interesting function, when using then backtracking algorithm, is
“<code class="docutils literal"><span class="pre">Grammar.Entry.parse_all</span></code>” which returns all solutions of a given
input.</p>
<p>See details in the chapter <a class="reference external" href="library.html">Library</a>, section
“Grammar module”.</p>
<p class="rubric" id="errors-and-recovery">Errors and recovery</p>
<p>In extensible grammars, the exceptions are encapsulated with the
exception “Ploc.Exc” giving the location of the error together with
the exception itself.</p>
<p>If the parsing algorithm is “<code class="docutils literal"><span class="pre">Grammar.Predictive</span></code>”, the system
internally uses <a class="reference external" href="parsers.html">stream parsers</a>. Two exceptions may
happen: “Stream.Failure” or “Stream.Error”. “Stream.Failure”
indicates that the parsing just could not start. “Stream.Error”
indicates that the parsing started but failed further.</p>
<p>With this algorithm, when the first symbol of a rule has been
accepted, all the symbols of the same rule must be accepted,
otherwise the exception “Stream.Error” is raised.</p>
<p>If the parsing algorithm is “<code class="docutils literal"><span class="pre">Grammar.Functional</span></code>” (resp.
“<code class="docutils literal"><span class="pre">Grammar.Backtracking</span></code>”), the system internally uses <a class="reference external" href="fparsers.html">functional
parsers</a> (resp <a class="reference external" href="bparsers.html">backtracking
parsers</a>. If no solution is found, the exception
“<code class="docutils literal"><span class="pre">Stream.Error</span></code>” is raised and the location of the error is the
location of the last unfrozen token, i.e. where the stream advanced
the farthest.</p>
<p>In extensible grammars, unlike stream parsers, before the
“Stream.Error” exception, the system attempts to recover the error by
the following trick: if the previous symbol of the rule was a call to
another entry, the system calls the “continue” function of that
entry, which may resolve the problem.</p>
<p class="rubric" id="tokens-starting-rules">Tokens starting rules</p>
<p>Another improvement (other than error recovery) is that when a rule
starts with several tokens and/or keywords, all these tokens and
keywords are tested in one time, and the possible “Stream.Error” may
happen, only from the symbol following them on, if any.</p>
<p class="rubric" id="the-grammar-module">The Grammar module</p>
<p>See its <a class="reference external" href="library.html#a:Grammar-module">section</a> in the chapter
“Library”.</p>
<p class="rubric" id="interface-with-the-lexer">Interface with the lexer</p>
<p>To create a grammar, the function “<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>” must be
called, with a lexer as parameter.</p>
<p>A simple solution, as possible lexer, is the predefined lexer built
by “<code class="docutils literal"><span class="pre">Plexer.gmake</span> <span class="pre">()</span></code>”, lexer used for the OCaml grammar of Camlp5.
In this case, you can just put it as parameter of
“<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>” and it is not necessary to read this section.</p>
<p>The section first introduces the notion of “token patterns” which are
the way the tokens and keywords symbols in the EXTEND statement are
represented. Then follow the description of the type of the parameter
of “<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>”.</p>
<p class="rubric" id="token-patterns">Token patterns</p>
<p>A token pattern is a value of the type defined like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">string</span><span class="p">);</span>
</pre></div>
</div>
<p>This type represents values of the token and keywords symbols in the
grammar rules.</p>
<p>For a token symbol in the grammar rules, the first string is the
token constructor name (starting with an uppercase character), the
second string indicates whether the match is “any” (the empty string)
or some specific value of the token (an non-empty string).</p>
<p>For a keyword symbol, the first string is empty and the second string
is the keyword itself.</p>
<p>For example, given this grammar rule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;for&quot;</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LIDENT</span><span class="p">;</span> <span class="s2">&quot;=&quot;</span><span class="p">;</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">SELF</span><span class="p">;</span> <span class="s2">&quot;to&quot;</span><span class="p">;</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">SELF</span>
</pre></div>
</div>
<p>the different symbols and keywords are represented by the following
couples of strings:</p>
<ul class="simple">
<li>the keyword “for” is represented by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;for&quot;)</span></code>,</li>
<li>the keyword “=” by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;=&quot;)</span></code>,</li>
<li>the keyword “to” by <code class="docutils literal"><span class="pre">(&quot;&quot;,</span> <span class="pre">&quot;to&quot;)</span></code>),</li>
<li>and the token symbol <code class="docutils literal"><span class="pre">LIDENT</span></code> by <code class="docutils literal"><span class="pre">(&quot;LIDENT&quot;,</span> <span class="pre">&quot;&quot;)</span></code>.</li>
</ul>
<p>The symbol <code class="docutils literal"><span class="pre">UIDENT</span> <span class="pre">&quot;Foo&quot;</span></code> in a rule would be represented by the
token pattern:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;UIDENT&quot;</span><span class="p">,</span> <span class="s2">&quot;Foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the symbol “<code class="docutils literal"><span class="pre">SELF</span></code>” is a specific symbol of the EXTEND
syntax: it does not correspond to a token pattern and is represented
differently. A token constructor name must not belong to the specific
symbols: SELF, NEXT, LIST0, LIST1, OPT and FLAG.</p>
<p class="rubric" id="the-lexer-record">The lexer record</p>
<p>The type of the parameter of the function “<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>” is
“<code class="docutils literal"><span class="pre">lexer</span></code>”, defined in the module “<code class="docutils literal"><span class="pre">Plexing</span></code>”. It is a record type
with the following fields:</p>
<p class="rubric" id="tok-func"><code class="docutils literal"><span class="pre">tok_func</span></code></p>
<p>It is the lexer itself. Its type is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Stream</span><span class="o">.</span><span class="n">t</span> <span class="n">char</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">t</span> <span class="p">(</span><span class="n">string</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="o">*</span> <span class="n">location_function</span><span class="p">);</span>
</pre></div>
</div>
<p>The lexer takes a character stream as parameter and return a couple
of containing: a token stream (the tokens being represented by a
couple of strings), and a location function.</p>
<p>The location function is a function taking, as parameter, a integer
corresponding to a token number in the stream (starting from zero),
and returning the location of this token in the source. This is
important to get good locations in the semantic actions of the
grammar rules.</p>
<p>Notice that, despite the lexer taking a character stream as
parameter, it is not mandatory to use the stream parsers technology
to write the lexer. What is important is that it does the job.</p>
<p class="rubric" id="tok-using"><code class="docutils literal"><span class="pre">tok_using</span></code></p>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span>
</pre></div>
</div>
<p>The parameter of this function is the representation of a token
symbol or a keyword symbol in grammar rules. See the section about
token patterns.</p>
<p>This function is called for each token symbol and each keyword
encountered in the grammar rules of the EXTEND statement. Its goal is
to allow the lexer to check that the tokens and keywords do respect
the lexer rules. It checks that the tokens exist and are not
mispelled. It can be also used to enter the keywords in the lexer
keyword tables.</p>
<p>Setting it as the function that does nothing is possible, but the
check of correctness of tokens is not done.</p>
<p>In case or error, the function must raise the exception
“<code class="docutils literal"><span class="pre">Plexing.Error</span></code>” with an error message as parameter.</p>
<p class="rubric" id="tok-removing"><code class="docutils literal"><span class="pre">tok_removing</span></code></p>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span>
</pre></div>
</div>
<p>It is possibly called by the DELETE_RULE statement for tokens and
keywords no longer used in the grammar. The grammar system maintains
a number of usages of all tokens and keywords and calls this function
only when this number reaches zero. This can be interesting for
keywords: the lexer can remove them from its tables.</p>
<p class="rubric" id="tok-match"><code class="docutils literal"><span class="pre">tok_match</span></code></p>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">string</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">unit</span><span class="p">)</span>
</pre></div>
</div>
<p>The function tells how a token of the input stream is matched against
a token pattern. Both are represented by a couple of strings.</p>
<p>This function takes a token pattern as parameter and return a
function matching a token, returning the matched string or raising
the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” if the token does not match.</p>
<p>Notice that, for efficiency, it is necessary to write this function
as a match of token patterns returning, for each case, the function
which matches the token, <em>not</em> a function matching the token pattern
and the token together and returning a string for each case.</p>
<p>An acceptable function is provided in the module “<code class="docutils literal"><span class="pre">Plexing</span></code>” and is
named “default_match”. Its code looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">default_match</span> <span class="o">=</span>
  <span class="n">fun</span>
  <span class="p">[</span> <span class="p">(</span><span class="n">p_con</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">prm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">con</span> <span class="o">=</span> <span class="n">p_con</span> <span class="n">then</span> <span class="n">prm</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span>
  <span class="o">|</span> <span class="p">(</span><span class="n">p_con</span><span class="p">,</span> <span class="n">p_prm</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">prm</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">con</span> <span class="o">=</span> <span class="n">p_con</span> <span class="o">&amp;&amp;</span> <span class="n">prm</span> <span class="o">=</span> <span class="n">p_prm</span> <span class="n">then</span> <span class="n">prm</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
<p class="rubric" id="tok-text"><code class="docutils literal"><span class="pre">tok_text</span></code></p>
<p>Is a function of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">string</span>
</pre></div>
</div>
<p>Designed for error messages, it takes a token pattern as parameter
and returns the string giving its name.</p>
<p>It is possible to use the predefined function “<code class="docutils literal"><span class="pre">lexer_text</span></code>” of the
Plexing module. This function just returns the name of the token
pattern constructor and its parameter if any.</p>
<p>For example, with this default function, the token symbol IDENT would
be written as IDENT in error message (e.g. “IDENT expected”). The
“text” function may decide to print it differently, e.g., as
“identifier”.</p>
<p class="rubric" id="tok-comm"><code class="docutils literal"><span class="pre">tok_comm</span></code></p>
<p>Is a mutable field of type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">option</span> <span class="p">(</span><span class="nb">list</span> <span class="n">location</span><span class="p">)</span>
</pre></div>
</div>
<p>It asks the lexer (the lexer function should do it) to record the
locations of the comments in the program. Setting this field to
“None” indicates that the lexer must not record them. Setting it to
“Some []” indicated that the lexer must put the comments location
list in the field, which is mutable.</p>
<p class="rubric" id="minimalist-version">Minimalist version</p>
<p>If a lexer have been written, named “<code class="docutils literal"><span class="pre">lexer</span></code>”, here is the
minimalist version of the value suitable as parameter to
“<code class="docutils literal"><span class="pre">Grammar.gcreate</span></code>”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">Plexing</span><span class="o">.</span><span class="n">tok_func</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_using</span> <span class="n">_</span> <span class="o">=</span> <span class="p">();</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_removing</span> <span class="n">_</span> <span class="o">=</span> <span class="p">();</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_match</span> <span class="o">=</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">default_match</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_text</span> <span class="o">=</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">lexer_text</span><span class="p">;</span>
 <span class="n">Plexing</span><span class="o">.</span><span class="n">tok_comm</span> <span class="o">=</span> <span class="kc">None</span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric" id="functorial-interface">Functorial interface</p>
<p>The normal interface for grammars described in the previous sections
has two drawbacks:</p>
<ul class="simple">
<li>First, the type of tokens of the lexers must be
“<code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">string)</span></code>”</li>
<li>Second, since the entry type has no parameter to specify the
grammar it is bound to, there is no static check that entries are
compatible, i.e. belong to the same grammar. The check is done at
run time.</li>
</ul>
<p>The functorial interface resolve these two problems. The functor
takes a module as parameter where the token type has to be defined,
together with the lexer returning streams of tokens of this type. The
resulting module define entries compatible the ones to the other, and
this is controlled by the OCaml type checker.</p>
<p>The syntax extension must be done with the statement GEXTEND, instead
of EXTEND, and deletion by GDELETE_RULE instead of DELETE_RULE.</p>
<p class="rubric" id="the-lexer-type">The lexer type</p>
<p>In the section about the interface with the lexer, we presented the
“<code class="docutils literal"><span class="pre">Plexing.lexer</span></code>” type as a record without type parameter.
Actually, this type is defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">lexer</span> <span class="s1">&#39;te =</span>
  <span class="p">{</span> <span class="n">tok_func</span> <span class="p">:</span> <span class="n">lexer_func</span> <span class="s1">&#39;te;</span>
    <span class="n">tok_using</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span><span class="p">;</span>
    <span class="n">tok_removing</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">unit</span><span class="p">;</span>
    <span class="n">tok_match</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="s1">&#39;te -&gt; string;</span>
    <span class="n">tok_text</span> <span class="p">:</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">string</span><span class="p">;</span>
    <span class="n">tok_comm</span> <span class="p">:</span> <span class="n">mutable</span> <span class="n">option</span> <span class="p">(</span><span class="nb">list</span> <span class="n">location</span><span class="p">)</span> <span class="p">}</span>
<span class="p">;</span>
</pre></div>
</div>
<p>where the type parameter is the type of the token, which can be any
type, different from “<code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span> <span class="pre">string)</span></code>”, providing the lexer
function (<code class="docutils literal"><span class="pre">tok_func</span></code>) returns a stream of this token type and the
match function (<code class="docutils literal"><span class="pre">tok_match</span></code>) indicates how to match values of this
token type against the token patterns (which remain defined as
“<code class="docutils literal"><span class="pre">(string</span> <span class="pre">*</span> <span class="pre">string)</span></code>”).</p>
<p>Here is an example of an user token type and the associated match
function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">mytoken</span> <span class="o">=</span>
  <span class="p">[</span> <span class="n">Ident</span> <span class="n">of</span> <span class="n">string</span>
  <span class="o">|</span> <span class="n">Int</span> <span class="n">of</span> <span class="nb">int</span>
  <span class="o">|</span> <span class="n">Comma</span> <span class="o">|</span> <span class="n">Equal</span>
  <span class="o">|</span> <span class="n">Keyw</span> <span class="n">of</span> <span class="n">string</span>  <span class="p">]</span>
<span class="p">;</span>

<span class="n">value</span> <span class="n">mymatch</span> <span class="o">=</span>
  <span class="n">fun</span>
  <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;IDENT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Ident</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;INT&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Int</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">i</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Comma</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span> <span class="p">[</span> <span class="n">Equal</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span> <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fun</span>
      <span class="p">[</span> <span class="n">Keyw</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span> <span class="n">then</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span>
      <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="p">]</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="p">(</span><span class="n">Plexing</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;bad token in match function&quot;</span><span class="p">)</span> <span class="p">]</span>
<span class="p">;</span>
</pre></div>
</div>
<p class="rubric" id="the-functor-parameter">The functor parameter</p>
<p>The type of the functor parameter is defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="nb">type</span> <span class="n">GLexerType</span> <span class="o">=</span>
  <span class="n">sig</span>
    <span class="nb">type</span> <span class="n">te</span> <span class="o">=</span> <span class="s1">&#39;x;</span>
    <span class="n">value</span> <span class="n">lexer</span> <span class="p">:</span> <span class="n">Plexing</span><span class="o">.</span><span class="n">lexer</span> <span class="n">te</span><span class="p">;</span>
  <span class="n">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The token type must be specified (type “<code class="docutils literal"><span class="pre">te</span></code>”) and the lexer also,
with the interface for lexers, of the lexer type defined above, the
record fields being described in the section “interface with the
lexer”, but with a general token type.</p>
<p class="rubric" id="the-resulting-grammar-module">The resulting grammar module</p>
<p>Once a module of type “<code class="docutils literal"><span class="pre">GLexerType</span></code>” has been built (previous
section), it is possible to create a grammar module by applying the
functor “<code class="docutils literal"><span class="pre">Grammar.GMake</span></code>”. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyGram</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">GMake</span> <span class="n">MyLexer</span><span class="p">;</span>
</pre></div>
</div>
<p>Notice that the function “<code class="docutils literal"><span class="pre">Entry.parse</span></code>” of this resulting module
does not take a character stream as parameter, but a value of type
“<code class="docutils literal"><span class="pre">parsable</span></code>”. This function is equivalent to the function
“<code class="docutils literal"><span class="pre">parse_parsable</span></code>” of the non functorial interface. In short, the
parsing of some character stream “<code class="docutils literal"><span class="pre">cs</span></code>” by some entry “<code class="docutils literal"><span class="pre">e</span></code>” of
the example grammar above, must be done by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MyGram</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="p">(</span><span class="n">MyGram</span><span class="o">.</span><span class="n">parsable</span> <span class="n">cs</span><span class="p">)</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MyGram</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="n">cs</span>
</pre></div>
</div>
<p class="rubric" id="gextend-and-gdelete-rule">GEXTEND and GDELETE_RULE</p>
<p>The “<code class="docutils literal"><span class="pre">GEXTEND</span></code>” and “<code class="docutils literal"><span class="pre">GDELETE_RULE</span></code>” statements are also added in
the expressions of the OCaml language when the syntax extension kit
“<code class="docutils literal"><span class="pre">pa_extend.cmo</span></code>” is loaded. They must be used for grammars defined
with the functorial interface. Their syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>         <span class="n">expression</span> <span class="p">:</span><span class="o">:=</span> <span class="n">gextend</span>
                      <span class="o">|</span> <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span>
       <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;GDELETE_RULE&quot;</span> <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
            <span class="n">gextend</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;GEXTEND&quot;</span> <span class="n">gextend</span><span class="o">-</span><span class="n">body</span> <span class="s2">&quot;END&quot;</span>
       <span class="n">gextend</span><span class="o">-</span><span class="n">body</span> <span class="p">:</span><span class="o">:=</span> <span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="n">extend</span><span class="o">-</span><span class="n">body</span>
  <span class="n">gdelete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span> <span class="p">:</span><span class="o">:=</span> <span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="n">delete</span><span class="o">-</span><span class="n">rule</span><span class="o">-</span><span class="n">body</span>
<span class="n">grammar</span><span class="o">-</span><span class="n">module</span><span class="o">-</span><span class="n">name</span> <span class="p">:</span><span class="o">:=</span> <span class="n">qualid</span>
</pre></div>
</div>
<p>See the syntax of the EXTEND statement for the meaning of the syntax
entries not defined above.</p>
<p class="rubric" id="an-example-arithmetic-calculator">An example: arithmetic calculator</p>
<p>Here is a small calculator of expressions. They are given as
parameters of the command.</p>
<p>File “calc.ml”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#load &quot;pa_extend.cmo&quot;;</span>

<span class="n">value</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">gcreate</span> <span class="p">(</span><span class="n">Plexer</span><span class="o">.</span><span class="n">gmake</span> <span class="p">());</span>
<span class="n">value</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">create</span> <span class="n">g</span> <span class="s2">&quot;expression&quot;</span><span class="p">;</span>

<span class="n">EXTEND</span>
  <span class="n">e</span><span class="p">:</span>
    <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;+&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;-&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;*&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
      <span class="o">|</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;/&quot;</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="p">]</span>
    <span class="o">|</span> <span class="p">[</span> <span class="n">x</span> <span class="o">=</span> <span class="n">INT</span> <span class="o">-&gt;</span> <span class="n">int_of_string</span> <span class="n">x</span>
      <span class="o">|</span> <span class="s2">&quot;(&quot;</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="s2">&quot;)&quot;</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span> <span class="p">]</span>
  <span class="p">;</span>
<span class="n">END</span><span class="p">;</span>

<span class="nb">open</span> <span class="n">Printf</span><span class="p">;</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">Array</span><span class="o">.</span><span class="n">length</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">-</span> <span class="mi">1</span> <span class="n">do</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">Entry</span><span class="o">.</span><span class="n">parse</span> <span class="n">e</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="ow">in</span>
  <span class="n">printf</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="n">Sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">flush</span> <span class="n">stdout</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The link needs the library “gramlib.cma” provided with Camlp5:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlc</span> <span class="o">-</span><span class="n">pp</span> <span class="n">camlp5r</span> <span class="o">-</span><span class="n">I</span> <span class="o">+</span><span class="n">camlp5</span> <span class="n">gramlib</span><span class="o">.</span><span class="n">cma</span> <span class="n">test</span><span class="o">/</span><span class="n">calc</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">o</span> <span class="n">calc</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ./calc &#39;239*4649&#39;
239*4649 = 1111111
$ ./calc &#39;(47+2)/3&#39;
(47+2)/3 = 16
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="printing-tools.html" class="btn btn-neutral float-right" title="Parsing tools" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bparsers.html" class="btn btn-neutral float-left" title="Backtracking parsers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2007-2017, INRIA (Institut National de Recherches en Informatique et Automatique). All rights reserved.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>