

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Stream parsers &mdash; Camlp5  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Stream lexers" href="lexers.html" />
    <link rel="prev" title="Printing tools" href="parsing-tools.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Camlp5
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="strict.html">Transitional and Strict modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ptools.html">Parsing and Printing tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="parsing-tools.html">Printing tools</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Stream parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lexers.html">Stream lexers</a></li>
<li class="toctree-l2"><a class="reference internal" href="fparsers.html">Functional parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="bparsers.html">Backtracking parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="grammars.html">Extensible grammars</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="printing-tools.html">Parsing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-extensions.html">Language extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Future work</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Camlp5</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="parsing-tools.html">Printing tools</a> &raquo;</li>
        
      <li>Stream parsers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/camlp5/camlp5/blob/master/doc/rstparsers.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="stream-parsers">
<h1>Stream parsers<a class="headerlink" href="#stream-parsers" title="Permalink to this headline">¶</a></h1>
<div class="docutils container" id="content">
<p class="top rubric" id="id1">Stream parsers</p>
<p>We describe here the syntax and the semantics of the parsers of
streams of Camlp5. Streams are kinds of lazy lists. The parsers of
these streams use recursive descendent method without backtracking,
which is the most natural one in functional languages. In particular,
parsers are normal functions.</p>
<p>Notice that the parsers have existed in OCaml since many years (the
beginning of the 90ies), but some new features have been added in
2007 (lookahead, “no error” optimization, let..in statement and left
factorization) in Camlp5 distribution. This chapter describes them
also.</p>
<p class="rubric" id="introduction">Introduction</p>
<p>Parsers apply to values of type “Stream.t” defined in the module
“Stream” of the standard library of OCaml. Like the type “list”, the
type “Stream.t” has a type parameter, indicating the type of its
elements. They differ from the lists that they are lazy (the elements
are evaluated as long as the parser need them for its actions), and
imperative (parsers deletes their first elements when they take their
parsing decisions): notice that purely functional parsers exist in
Camlp5, where the corresponding streams are lazy and functional, the
analyzed elements remaining in the initial stream and the semantic
action returning the resulting stream together with the normal
result, which allow natural limited backtrack but have the drawback
that it is not easy to find the position of parsing errors when they
happen.</p>
<p>Parsers of lazy+imperative streams, which are described here, use a
method named “recursive descendent”: they look at the first element,
they decide what to do in function of its value, and continue the
parsing with the remaining elements. Parsers can call other parsers,
and can be recursive, like normal functions.</p>
<p>Actually, parsers are just pure syntactic sugar. When writing a
parser in the syntax of the parser, Camlp5 transforms them into
normal call to functions, use of patterns matchings and try..with
statements. The pretty printer of Camlp5, by default, displays this
expanded result, without syntax of parsers. A pretty printing kit,
when added, can rebuild the parsers in their initial syntax and
display it.</p>
<p class="rubric" id="syntax">Syntax</p>
<p>The syntax of the parsers, when loading “pa_rp.cmo” (or already
included in the command “camlp5r”), is the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>          <span class="n">expression</span> <span class="p">:</span><span class="o">:=</span> <span class="n">parser</span>
                       <span class="o">|</span> <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">parser</span>
              <span class="n">parser</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;parser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;[&quot;</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="s2">&quot;]&quot;</span>
                       <span class="o">|</span> <span class="s2">&quot;parser&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
   <span class="n">match</span><span class="o">-</span><span class="k">with</span><span class="o">-</span><span class="n">parser</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;match&quot;</span> <span class="n">expression</span> <span class="s2">&quot;with&quot;</span> <span class="n">parser</span>
        <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="p">:</span><span class="o">:=</span> <span class="n">parser</span><span class="o">-</span><span class="n">cases</span> <span class="n">parser</span><span class="o">-</span><span class="n">case</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
         <span class="n">parser</span><span class="o">-</span><span class="n">case</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;[:&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="s2">&quot;:]&quot;</span> <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="n">expression</span>
      <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span> <span class="p">:</span><span class="o">:=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
                       <span class="o">|</span> <span class="s2">&quot;let&quot;</span> <span class="n">LIDENT</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span> <span class="s2">&quot;in&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">pattern</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span> <span class="p">:</span><span class="o">:=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span> <span class="s2">&quot;;&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
                       <span class="o">|</span> <span class="s2">&quot;let&quot;</span> <span class="n">LIDENT</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span> <span class="s2">&quot;in&quot;</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">cont</span>
<span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span><span class="o">-</span><span class="n">err</span> <span class="p">:</span><span class="o">:=</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;?&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="s2">&quot;!&quot;</span>
    <span class="n">stream</span><span class="o">-</span><span class="n">patt</span><span class="o">-</span><span class="n">comp</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="s2">&quot;`&quot;</span> <span class="n">pattern</span> <span class="s2">&quot;when&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="s2">&quot;?=&quot;</span> <span class="n">lookaheads</span>
                       <span class="o">|</span> <span class="n">pattern</span> <span class="s2">&quot;=&quot;</span> <span class="n">expression</span>
                       <span class="o">|</span> <span class="n">pattern</span>
          <span class="n">lookaheads</span> <span class="p">:</span><span class="o">:=</span> <span class="n">lookaheads</span> <span class="s2">&quot;|&quot;</span> <span class="n">lookahead</span>
                       <span class="o">|</span> <span class="n">lookahead</span>
           <span class="n">lookahead</span> <span class="p">:</span><span class="o">:=</span> <span class="s2">&quot;[&quot;</span> <span class="n">patterns</span> <span class="s2">&quot;]&quot;</span>
            <span class="n">patterns</span> <span class="p">:</span><span class="o">:=</span> <span class="n">patterns</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="n">pattern</span>
             <span class="n">pos</span><span class="o">-</span><span class="n">opt</span> <span class="p">:</span><span class="o">:=</span> <span class="n">pattern</span>
                       <span class="o">|</span> <span class="o">&lt;</span><span class="n">nothing</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="rubric" id="streams">Streams</p>
<p>The parsers are functions taking streams as parameter. Streams are
are values of type “<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span></code>” for some type “<code class="docutils literal"><span class="pre">a</span></code>”. It is
possible to build streams using the functions defined in the module
“<code class="docutils literal"><span class="pre">Stream</span></code>”:</p>
<p class="rubric" id="stream-from">Stream.from</p>
<p>“<code class="docutils literal"><span class="pre">Stream.from</span> <span class="pre">f</span></code>” returns a stream built from the function “<code class="docutils literal"><span class="pre">f</span></code>”.
To create a new stream element, the function “<code class="docutils literal"><span class="pre">f</span></code>” is called with
the current stream count, starting with zero. The user function
“<code class="docutils literal"><span class="pre">f</span></code>” must return either “<code class="docutils literal"><span class="pre">Some</span> <span class="pre">&lt;value&gt;</span></code>” for a value or
“<code class="docutils literal"><span class="pre">None</span></code>” to specify the end of the stream.</p>
<p class="rubric" id="stream-of-list">Stream.of_list</p>
<p>Return a stream built from the list in the same order.</p>
<p class="rubric" id="stream-of-string">Stream.of_string</p>
<p>Return a stream of the characters of the string parameter.</p>
<p class="rubric" id="stream-of-channel">Stream.of_channel</p>
<p>Return a stream of the characters read from the input channel
parameter.</p>
<p class="rubric" id="semantics-of-parsers">Semantics of parsers</p>
<p class="rubric" id="parser">Parser</p>
<p>A parser, defined with the syntax “parser” above, is of type
“<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>” where “a” is the type of the elements of the
streams and “b” the type of the result. The parser cases are tested
in the order they are defined until one of them applies. The result
is the semantic action of the parser case which applies. If no parser
case applies, the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” is raised.</p>
<p>When testing a parser case, if the first stream pattern component
matches, all remaining stream pattern components of the stream
pattern must match also. If one does not match, the parser raises the
exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>” which has a parameter of type string: by
default, this string is the empty string, but if the stream pattern
component which does not match is followed by a question mark and an
expression, this expression is evaluated and given as parameter to
“<code class="docutils literal"><span class="pre">Stream.Error</span></code>”.</p>
<p>In short, a parser can return with three ways:</p>
<ul class="simple">
<li>A normal result, of type “<code class="docutils literal"><span class="pre">b</span></code>” for a parser of type
“<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>”.</li>
<li>Raising the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>”.</li>
<li>Raising the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>”.</li>
</ul>
<p>Fundamentally, the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” means “this parser
does not apply and no element have been removed from the initial
stream”. This is a normal case when parsing: the parser locally
fails, but the parsing can continue.</p>
<p>Conversely, the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>” means that “this parser
encountered a syntax error and elements have probably been removed
from the stream”. In this case, there is no way to recover the
parsing, and it definitively fails.</p>
<p class="rubric" id="left-factorization">Left factorization</p>
<p>In parsers, <em>consecutive</em> rules starting with the same components are
left factorized. It means that they are transformed into one only
rule starting with the common path, and continuing with a call to a
parser separating the two cases. The order is kept, except that the
possible empty rule is inserted at the end.</p>
<p>For example, the parser:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; f e1 e2 e3
| [: `If; e1 = expr; `Then; e2 = expr :] -&gt; g e1 e2 ]
</pre></div>
</div>
<p>is transformed into:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `If; e1 = expr; `Then; e2 = expr;
     a =
       parser
       [ [: `Else; e3 = expr :] -&gt; f e1 e2 e3
       | [: :] -&gt; g e1 e2 ] :] -&gt; a
</pre></div>
</div>
<p>The version where rules are inverted:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr :] -&gt; g e1 e2
| [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; f e1 e2 e3 ]
</pre></div>
</div>
<p>is transformed into the same parser.</p>
<p>Notice that:</p>
<ul>
<li><p class="first">Only <em>consecutive</em> rules are left factorized. In the following
parser:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; ...
| [: a = b :] -&gt; a
| [: `If; e1 = expr; `Then; e2 = expr :] -&gt; ... ]
</pre></div>
</div>
<p>the two rules starting with “<code class="docutils literal"><span class="pre">If</span></code>” are not left factorized, and
the second “<code class="docutils literal"><span class="pre">If</span></code>” rule will never work.</p>
</li>
<li><p class="first">The components which are not <em>identical</em> are not factorized. In
the following parser:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
[ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -&gt; ...
| [: `If; e4 = expr; `Then; e2 = expr :] -&gt; ... ]
</pre></div>
</div>
<p>only the first component, “<code class="docutils literal"><span class="pre">If</span></code>” is factorized, the second one
being different because of different patterns (“<code class="docutils literal"><span class="pre">e1</span></code>” and
“<code class="docutils literal"><span class="pre">e4</span></code>”).</p>
</li>
</ul>
<p class="rubric" id="match-with-parser">Match with parser</p>
<p>The syntax “match expression with parser” allows to match a stream
against a parser. It is, for “parser”, the equivalent of “match
expression with” for “fun”. The same way we could say:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="n">expression</span> <span class="k">with</span> <span class="o">...</span>
</pre></div>
</div>
<p>could be considered as an equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">fun</span> <span class="o">...</span><span class="p">)</span> <span class="n">expression</span>
</pre></div>
</div>
<p>we could consider that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="n">expression</span> <span class="k">with</span> <span class="n">parser</span> <span class="o">...</span>
</pre></div>
</div>
<p>is an equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">parser</span> <span class="o">...</span><span class="p">)</span> <span class="n">expression</span>
</pre></div>
</div>
<p class="rubric" id="error-messages">Error messages</p>
<p>A “<code class="docutils literal"><span class="pre">Stream.Error</span></code>” exception is raised when a stream pattern
component does not match and that it is not the first one of the
parser case. This exception has a parameter of type string, useful to
specify the error message. By default, this is the empty string. To
specify an error message, add a question mark and an expression after
the stream pattern component. A typical error message is “that stream
pattern component expected”. Example with the parser of
“if..then..else..” above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `If; e1 = expr ? &quot;expression expected after &#39;if&#39;&quot;;
     `Then ? &quot;&#39;then&#39; expected&quot;;
     e2 = expr ? &quot;expression expected after &#39;then&#39;&quot;;
     a =
       parser
       [ [: `Else; e3 = expr ? &quot;expression expected&quot; :] -&gt; f e1 e2 e3
       | [: :] -&gt; g e1 e2 ] :] -&gt; a
</pre></div>
</div>
<p>Notice that the expression after the question mark is evaluated only
in case of syntax error. Therefore, it can be a complicated call to a
complicated function without slowing down the normal parsing.</p>
<p class="rubric" id="stream-pattern-component">Stream pattern component</p>
<p>In a stream pattern (starting with “<code class="docutils literal"><span class="pre">[:</span></code>” and ending with
“<code class="docutils literal"><span class="pre">:]</span></code>”), the stream pattern components are separated with the
semicolon character. There are three cases of stream pattern
components with some sub-cases for some of them, and an extra syntax
can be used with a “let..in” construction. The three cases are:</p>
<ul>
<li><p class="first">A direct test of one or several stream elements (called
<strong>terminal</strong> symbol), in three ways:</p>
<ol class="arabic simple">
<li>The character “backquote” followed by a pattern, meaning: if
the stream starts with an element which is matched by this
pattern, the stream pattern component matches, and the stream
element is removed from the stream.</li>
<li>The character “backquote” followed by a pattern, the keyword
“when” and an expression of type “<code class="docutils literal"><span class="pre">bool</span></code>”, meaning: if the
stream starts with an element which is matched by this pattern
and if the evaluation of the expression is “<code class="docutils literal"><span class="pre">True</span></code>”, the
stream pattern component matches, and the first element of the
stream is removed.</li>
<li>The character “question mark” followed by the character “equal”
and a lookahead expression (see further), meaning: if the
lookahead applies, the stream pattern component matches. The
lookahead may unfreeze one or several elements on the stream,
but does not remove them.</li>
</ol>
</li>
<li><p class="first">A pattern followed by the “equal” sign and an expression of type
“<code class="docutils literal"><span class="pre">Stream.t</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code>” for some types “<code class="docutils literal"><span class="pre">x</span></code>” and “<code class="docutils literal"><span class="pre">y</span></code>”. This
expression is called a <strong>non terminal</strong> symbol. It means: call the
expression (which is a parser) with the current stream. If this
sub-parser:</p>
<ol class="arabic">
<li><p class="first">Returns an element, the pattern is bound to this result and the
next stream pattern component is tested.</p>
</li>
<li><p class="first">Raises the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>”, there are two cases:</p>
<ul class="simple">
<li>if the stream pattern component is the first one of the
stream case, the current parser also fails with the
exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>”.</li>
<li>if the stream pattern component is not the first one of the
stream case, the current parser fails with the exception
“<code class="docutils literal"><span class="pre">Stream.Error</span></code>”.</li>
</ul>
<p>In this second case:</p>
<ul class="simple">
<li>If the stream pattern component is followed by a “question
mark” and an expression (which must be of type
“<code class="docutils literal"><span class="pre">string</span></code>”), the expression is evaluated and given as
parameter of the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>”.</li>
<li>If the expression is followed by an “exclamation mark”, the
test and conversion from “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” to
“<code class="docutils literal"><span class="pre">Stream.Error</span></code>” is not done, and the parser just raises
“<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” again. This is an optimization which
must be assumed by the programmer, in general when he knows
that the sub-parser called never raises “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>”
(for example if the called parser ends with a parser case
containing an empty stream pattern). See “no error
optionization” below.</li>
<li>Otherwise the exception parameter is the empty string.</li>
</ul>
</li>
</ol>
</li>
<li><p class="first">A pattern, which is bound to the current stream.</p>
</li>
</ul>
<p>Notice that patterns are bound immediately and can be used in the
next stream pattern component.</p>
<p class="rubric" id="let-statement">Let statement</p>
<p>Between stream pattern components, it is possible to use the
“let..in” construction. This is not considered as a real stream
pattern component, in the fact that is is not tested against the
exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>” it may raise. It can be useful for
intermediate computation. In particular, it is used internally by the
lexers (see chapter about <a class="reference external" href="lexers.html">lexers</a> as character
stream parsers).</p>
<p>Example of use, when an expression have to be used several times (in
the example, “<code class="docutils literal"><span class="pre">d</span> <span class="pre">a</span></code>”, which is bound to the variable “<code class="docutils literal"><span class="pre">c</span></code>”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span>
  <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="n">a</span> <span class="ow">in</span>
     <span class="n">e</span> <span class="o">=</span>
       <span class="n">parser</span>
       <span class="p">[</span> <span class="p">[:</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="n">c</span>
       <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="p">]</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
<p class="rubric" id="lookahead">Lookahead</p>
<p>The lookahead feature allows to look at several terminals in the
stream without removing them, in order to take decisions when more
than one terminal is necessary.</p>
<p>For example, when parsing the normal syntax of the OCaml language,
there is a problem, in recursing descendent parsing, for the cases
where to treat and differentiate the following inputs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="o">-</span><span class="p">)</span>
</pre></div>
</div>
<p>The first case is treated in a rule, telling: “a left parenthesis,
followed by an expression, and a right parenthesis”. The second one
is “a left parenthesis, an operator, a right parenthesis”.
Programming it like this (left factorizing the first parenthesis):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: e = expr; `Rparen :] -&gt; e
       | [: `Minus; `Rparen :] -&gt; minus_op ] :] -&gt; e
</pre></div>
</div>
<p>does not work if the input is “<code class="docutils literal"><span class="pre">(-)</span></code>” because the rule
“<code class="docutils literal"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">expr</span></code>” accepts the minus sign as expression start, removing
it from the input stream and fails as parsing error, while
encountering the right parenthesis.</p>
<p>Conversely, writing it this way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: `Minus; `Rparen :] -&gt; minus_op
       | [: e = expr; `Rparen :] -&gt; e ] :] -&gt; e
</pre></div>
</div>
<p>does not help, because if the input is “<code class="docutils literal"><span class="pre">(-x+1)</span></code>” the rule above
starting with “<code class="docutils literal"><span class="pre">`Minus</span></code>” is accepted and the exception
“<code class="docutils literal"><span class="pre">Stream.Error</span></code>” is raised while encountering the variable “<code class="docutils literal"><span class="pre">x</span></code>”
since a right parenthesis is expected.</p>
<p>In general, this kind of situation is best resolved by a left
factorization of the parser cases (see the section “Semantics”
above), but that is not possible in this case. The solution is to
test whether the character after the minus sign is a right
parenthesis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser
  [: `Lparen;
     e =
       parser
       [ [: ?= [ _ Rparen ]; `Minus; `Rparen :] -&gt; minus_op
       | [: e = expr; `Rparen :] -&gt; e ] :] -&gt; e
</pre></div>
</div>
<p>It is possible to put several lists of patterns separated by a
vertical bar in the lookahead construction, but with a limitation
(due to the implementation): all lists of patterns must have the same
number of elements.</p>
<p class="rubric" id="no-error-optimization">No error optimization</p>
<p>The “no error optimization” is the fact to end a stream pattern
component of kind “non-terminal” (“pattern” “equal” “expression”) by
the character “exclamation mark”. Like said above, this inhibits the
transformation of the exception “<code class="docutils literal"><span class="pre">Stream.Failure</span></code>”, possibly raised
by the called parser, into the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>”.</p>
<p>The code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser [: a = b; c = d ! :] -&gt; e
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">e</span>
</pre></div>
</div>
<p>One interest of the first syntax is that it shows to readers that
“<code class="docutils literal"><span class="pre">d</span></code>” is indeed a syntactic sub-parser. In the second syntax, it is
called in the semantic action, which makes the parser case not so
clear, as far as readability is concerned.</p>
<p>If the stream pattern component is at end of the stream pattern, this
allow possible tail recursion by the OCaml compiler, in the following
case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parser [: a = b; c = d ! :] -&gt; c
</pre></div>
</div>
<p>since it is equivalent (with the fact that “<code class="docutils literal"><span class="pre">c</span></code>” is at the same
time the pattern of the last case and the expression of the parser
case semantic action) to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">d</span> <span class="n">s</span>
</pre></div>
</div>
<p>The call to “<code class="docutils literal"><span class="pre">d</span> <span class="pre">s</span></code>” can be a tail recursive call. Without the use
of the “exclamation mark” in the rule, the equivalent code is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span>
  <span class="k">try</span> <span class="n">d</span> <span class="n">s</span> <span class="k">with</span> <span class="p">[</span> <span class="n">Stream</span><span class="o">.</span><span class="n">Failure</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">Error</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>which is not tail recursive (due to the “try..with” construction
pushes a context), preventing the compiler to optimize its code. This
can be important when many recursive calls happen, since it can
overflow the OCaml stack.</p>
<p class="rubric" id="position">Position</p>
<p>The optional “pattern” before and after a stream pattern is bound to
the current stream count. Indeed, streams internally contain a count
of their elements. At the beginning the count is zero. When an
element is removed, the count is incremented. The example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">:]</span> <span class="n">ep</span> <span class="o">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">s</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">let</span> <span class="n">ep</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="n">count</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">c</span>
</pre></div>
</div>
<p>There is no direct syntax equivalent to the optional pattern at
beginning of the stream pattern:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="n">bp</span> <span class="p">[:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>These optional patterns allow disposal of the stream count at the
beginning and at the end of the parser case, allowing to compute
locations of the rule in the source. In particular, if the stream is
a stream of characters, these counts are the source location in
number of characters.</p>
<p class="rubric" id="semantic-action">Semantic action</p>
<p>In a parser case, after the stream pattern, there is an “arrow” and
an expression, called the “semantic action”. If the parser case is
matched the parser returns with the evaluated expression whose
environment contains all values bound in the stream pattern.</p>
<p class="rubric" id="remarks">Remarks</p>
<p class="rubric" id="simplicity-vs-associativity">Simplicity vs Associativity</p>
<p>This parsing technology has the advantage of simplicity of use and
understanding, but it does not treat the associativity of operators.
For example, if you write a parser like this (to compute arithmetic
expressions):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>value rec expr =
  parser
  [ [: e1 = expr; `&#39;+&#39;; e2 = expr :] -&gt; e1 + e2
  | [: `(&#39;0&#39;..&#39;9&#39; as c) :] -&gt; Char.code c - Char.code &#39;0&#39; ]
</pre></div>
</div>
<p>this would loop endlessly, exactly as if you wrote code starting
with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">rec</span> <span class="n">expr</span> <span class="n">e</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">expr</span> <span class="n">e</span> <span class="ow">in</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>One solution is to treat the associativity “by hand”: by reading a
sub-expression, then looping with a parser which parses the operator
and another sub-expression, and so on.</p>
<p>An alternative solution is to write parsing “combinators”. Indeed,
parsers being normal functions, it is possible to make a function
which takes a parser as parameter and returning a parser using it.
For example, left and right associativity parsing combinators:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="n">rec</span> <span class="n">left_assoc</span> <span class="n">op</span> <span class="n">elem</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">rec</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">parser</span>
    <span class="p">[</span> <span class="p">[:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="p">(</span><span class="n">t</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
    <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span>
  <span class="ow">in</span>
  <span class="n">parser</span> <span class="p">[:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="p">;</span>

<span class="n">value</span> <span class="n">rec</span> <span class="n">right_assoc</span> <span class="n">op</span> <span class="n">elem</span> <span class="o">=</span>
  <span class="n">let</span> <span class="n">rec</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">parser</span>
    <span class="p">[</span> <span class="p">[:</span> <span class="n">t</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">y</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="n">x</span> <span class="n">r</span>
    <span class="o">|</span> <span class="p">[:</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">]</span>
  <span class="ow">in</span>
  <span class="n">parser</span> <span class="p">[:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">op_elem</span> <span class="n">x</span> <span class="p">:]</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="p">;</span>
</pre></div>
</div>
<p>which can be used, e.g. like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>value expr =
  List.fold_right (fun op elem -&gt; op elem)
    [left_assoc (parser [: `&#39;+&#39; :] -&gt; fun x y -&gt; x +. y);
     left_assoc (parser [: `&#39;*&#39; :] -&gt; fun x y -&gt; x *. y);
     right_assoc (parser [: `&#39;^&#39; :] -&gt; fun x y -&gt; x ** y)]
    (parser [: `(&#39;0&#39;..&#39;9&#39; as c) :] -&gt; float (Char.code c - Char.code &#39;0&#39;))
;
</pre></div>
</div>
<p>and tested, e.g. in the toplevel, like that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="p">(</span><span class="n">Stream</span><span class="o">.</span><span class="n">of_string</span> <span class="s2">&quot;2^3^2+1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The same way, it is possible to parse non-context free grammars, by
programming parsers returning other parsers.</p>
<p>A third solution, to resolve the problem of associativity, is to use
the grammars of Camlp5, which have the other advantage that they are
extensible.</p>
<p class="rubric" id="lexing-vs-parsing">Lexing vs Parsing</p>
<p>In general, while analyzing a language, there are two levels:</p>
<ul class="simple">
<li>The level where the input, considered as a stream of characters,
is read to make a stream of tokens (for example “words”, if it is
a human language, or punctuation). This level is generally called
“lexing”.</li>
<li>The level where the input is a stream of tokens where grammar
rules are parsed. This level is generally called “parsing”.</li>
</ul>
<p>The “parser” construction described here can be used for both, thanks
to the polymorphism of OCaml:</p>
<ul class="simple">
<li>The lexing level is a “parser” of streams of characters returning
tokens.</li>
<li>The parsing level is a “parser” of streams of tokens returning
syntax trees.</li>
</ul>
<p>By comparison, the programs “lex” and “yacc” use two different
technologies. With “parser”s, it is possible to use the same one for
both.</p>
<p class="rubric" id="lexer-syntax-vs-parser-syntax">Lexer syntax vs Parser syntax</p>
<p>For “lexers”, i.e. for the specific case of parsers when the input is
a stream of characters, it is possible to use a shorter syntax. See
the chapter on <a class="reference external" href="lexers.html">lexers</a>. They have another syntax,
shorter and adapted for the specific type “<code class="docutils literal"><span class="pre">char</span></code>”. But they still
are internally parsers of streams with the same semantics.</p>
<p class="rubric" id="purely-functional-parsers">Purely functional parsers</p>
<p>This system of parsers is imperative: while parsing, the stream
advances and the already parsed terminals disappear from the stream
structure. This is useful because it is not necessary to return the
remaining stream together with the normal result. This is the reason
there is this “<code class="docutils literal"><span class="pre">Stream.Error</span></code>” exception: when it is raised, it
means that some terminals have been consummed from the stream, which
are definitively lost, and therefore that are no more possible parser
cases to try.</p>
<p>An alternative is to use <a class="reference external" href="fparsers.html">functional parsers</a> which
use a new stream type, lazy but not destructive. Their advantage is
that they use a limited backtrack: the case of “if..then..else..” and
the shorter “if..then..” work without having to left factorize the
parser cases, and there is no need to lookahead. They have no
equivalent to the exception “<code class="docutils literal"><span class="pre">Stream.Error</span></code>”: when all cases are
tested, and have failed, the parsers return the value “<code class="docutils literal"><span class="pre">None</span></code>”. The
drawback is that, when a parsing error happens, it is not easily
possible to know the location of the error in the input, as the
initial stream has not been modified: the system would indicate a
failure at the first character of the first line: this is a general
drawback of backtracking parsers. See the solutions found to this
problem in the chapter about <a class="reference external" href="fparsers.html">purely functional
parsers</a>.</p>
<p>A second alternative is to use the <a class="reference external" href="bparsers.html">backtracking
parsers</a>. They use the same stream type as the
functional parsers, but they test more cases than them. They have the
same advantages and drawbacks than the functional parsers.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lexers.html" class="btn btn-neutral float-right" title="Stream lexers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parsing-tools.html" class="btn btn-neutral float-left" title="Printing tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2007-2017, INRIA (Institut National de Recherches en Informatique et Automatique). All rights reserved.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>