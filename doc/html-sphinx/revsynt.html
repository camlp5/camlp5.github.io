

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The revised syntax &mdash; Camlp5  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Scheme" href="scheme.html" />
    <link rel="prev" title="Quotations" href="quot.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Camlp5
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="strict.html">Transitional and Strict modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="ptools.html">Parsing and Printing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="parsing-tools.html">Printing tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="printing-tools.html">Parsing tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="language-extensions.html">Language extensions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="locations.html">Locations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ml_ast.html">Syntax tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="ast_transi.html">Syntax tree - transitional mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="ast_strict.html">Syntax tree - strict mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="q_ast.html">Syntax tree quotations in user syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="pcaml.html">The Pcaml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html">Directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="syntext.html">Extensions of syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="opretty.html">Extensions of printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="redef.html">Redefining OCaml syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="quot.html">Quotations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The revised syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html">Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html#ocaml-scheme">OCaml                                     Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheme.html#ocaml-lisp">OCaml                                     Lisp</a></li>
<li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="pragma.html">Pragma directive</a></li>
<li class="toctree-l2"><a class="reference internal" href="extfun.html">Extensible functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="conclusion.html">Future work</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Camlp5</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="language-extensions.html">Language extensions</a> &raquo;</li>
        
      <li>The revised syntax</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/camlp5/camlp5/blob/master/doc/rstrevsynt.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-revised-syntax">
<h1>The revised syntax<a class="headerlink" href="#the-revised-syntax" title="Permalink to this headline">¶</a></h1>
<div class="docutils container" id="content">
<p class="top rubric" id="id1">The revised syntax</p>
<p>The revised syntax is an alternative syntax of OCaml. It is close to
the normal syntax. We present here only the differences between the
two syntaxes.</p>
<p>Notice that there is a simple way to know how the normal syntax is
written in revised syntax: write the code in a file “foo.ml” in
normal syntax and type, in a shell:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5o</span> <span class="n">pr_r</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_rp</span><span class="o">.</span><span class="n">cmo</span> <span class="n">foo</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>And, conversely, how a file “bar.ml” written in revised syntax is
displayed in normal syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5r</span> <span class="n">pr_o</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_op</span><span class="o">.</span><span class="n">cmo</span> <span class="n">bar</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>Even simpler, without creating a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">camlp5o</span> <span class="n">pr_r</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_op</span><span class="o">.</span><span class="n">cmo</span> <span class="o">-</span><span class="n">impl</span> <span class="o">-</span>
<span class="o">...</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">normal</span> <span class="n">syntax</span> <span class="o">...</span>
<span class="o">...</span> <span class="nb">type</span> <span class="n">control</span><span class="o">-</span><span class="n">D</span> <span class="o">...</span>
<span class="n">camlp5r</span> <span class="n">pr_o</span><span class="o">.</span><span class="n">cmo</span> <span class="n">pr_rp</span><span class="o">.</span><span class="n">cmo</span> <span class="o">-</span><span class="n">impl</span> <span class="o">-</span>
<span class="o">...</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">revised</span> <span class="n">syntax</span> <span class="o">...</span>
<span class="o">...</span> <span class="nb">type</span> <span class="n">control</span><span class="o">-</span><span class="n">D</span> <span class="o">...</span>
</pre></div>
</div>
<p class="rubric" id="lexing">Lexing</p>
<ul class="simple">
<li>The character quote (<code class="docutils literal"><span class="pre">'</span></code>) can be written without backslash:
======== =======
OCaml    Revised
======== =======
<code class="docutils literal"><span class="pre">'\''</span></code> <code class="docutils literal"><span class="pre">'''</span></code>
======== =======</li>
</ul>
<p class="rubric" id="modules-structure-and-signature-items">Modules, Structure and Signature items</p>
<ul>
<li><p class="first">Structure and signature items always end with a single semicolon
which is required.</p>
</li>
<li><p class="first">In structures, the declaration of a value is introduced by the
keyword “value”, instead of “let”:
========================= ========================
OCaml                     Revised
========================= ========================
<code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">42;;</span></code>          <code class="docutils literal"><span class="pre">value</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">42;</span></code>
<code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">42</span> <span class="pre">in</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">7;;</span></code> <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">42</span> <span class="pre">in</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">7;</span></code>
========================= ========================</p>
</li>
<li><p class="first">In signatures, the declaration of a value is also introduced by
the keyword “value”, instead of “val”:
================= ==================
OCaml             Revised
================= ==================
<code class="docutils literal"><span class="pre">val</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">int;;</span></code> <code class="docutils literal"><span class="pre">value</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">int;</span></code>
================= ==================</p>
</li>
<li><p class="first">In signatures, abstract module types are represented by a quote
and an (any) identifier:
==================== ========================
OCaml                Revised
==================== ========================
<code class="docutils literal"><span class="pre">module</span> <span class="pre">type</span> <span class="pre">MT;;</span></code> <code class="docutils literal"><span class="pre">module</span> <span class="pre">type</span> <span class="pre">MT</span> <span class="pre">=</span> <span class="pre">'a;</span></code>
==================== ========================</p>
</li>
<li><p class="first">Functor application uses currying. Parentheses are not required
for the parameters:
=================================== ==============================
OCaml                               Revised
=================================== ==============================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">Set.Make(M).t;;</span></code>        <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">(Set.Make</span> <span class="pre">M).t;</span></code>
<code class="docutils literal"><span class="pre">module</span> <span class="pre">M</span> <span class="pre">=</span> <span class="pre">Mod.Make</span> <span class="pre">(M1)</span> <span class="pre">(M2);;</span></code> <code class="docutils literal"><span class="pre">module</span> <span class="pre">M</span> <span class="pre">=</span> <span class="pre">Mod.Make</span> <span class="pre">M1</span> <span class="pre">M2;</span></code>
=================================== ==============================</p>
</li>
<li><p class="first">It is possible to group several declarations together either in an
interface or in an implementation by enclosing them between
“declare” and “end” (this is useful when using syntax extensions
to generate several declarations from one). Example in an
interface:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">declare</span>
  <span class="nb">type</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Foo</span> <span class="n">of</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Bar</span> <span class="p">];</span>
  <span class="n">value</span> <span class="n">f</span> <span class="p">:</span> <span class="n">foo</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p class="rubric" id="expressions-and-patterns">Expressions and Patterns</p>
<p class="rubric" id="imperative-constructions">Imperative constructions</p>
<ul class="simple">
<li>The sequence is introduced by the keyword “do” followed by “{” and
terminated by “}”; it is possible to put a semicolon after the
last expression:
================== =========================
OCaml              Revised
================== =========================
<code class="docutils literal"><span class="pre">e1;</span> <span class="pre">e2;</span> <span class="pre">e3;</span> <span class="pre">e4</span></code> <code class="docutils literal"><span class="pre">do</span> <span class="pre">{</span> <span class="pre">e1;</span> <span class="pre">e2;</span> <span class="pre">e3;</span> <span class="pre">e4</span> <span class="pre">}</span></code>
================== =========================</li>
<li>The “do” after the “while” loop and the “for” loop are followed by
a “{” and the loop end with “}”; it is possible to put a semicolon
after the last expression:
========================= =========================
OCaml                     Revised
========================= =========================
<code class="docutils literal"><span class="pre">while</span> <span class="pre">e1</span> <span class="pre">do</span></code>           <code class="docutils literal"><span class="pre">while</span> <span class="pre">e1</span> <span class="pre">do</span> <span class="pre">{</span></code>
``&nbsp;&nbsp;e1; e2; e3``          ``&nbsp;&nbsp;e1; e2; e3``
<code class="docutils literal"><span class="pre">done</span></code>                  <code class="docutils literal"><span class="pre">}</span></code>
<a href="#id2"><span class="problematic" id="id3">``</span></a>``                      <a href="#id4"><span class="problematic" id="id5">``</span></a>``
<code class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">e1</span> <span class="pre">to</span> <span class="pre">e2</span> <span class="pre">do&nbsp;&nbsp;``</span> <span class="pre">``for</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">e1</span> <span class="pre">to</span> <span class="pre">e2</span> <span class="pre">do</span> <span class="pre">{</span></code>
``&nbsp;&nbsp;e1; e2; e3``          ``&nbsp;&nbsp;e1; e2; e3``
<code class="docutils literal"><span class="pre">done</span></code>                  <code class="docutils literal"><span class="pre">}</span></code>
========================= =========================</li>
</ul>
<p class="rubric" id="tuples-and-lists">Tuples and Lists</p>
<ul class="simple">
<li>Parentheses are required in tuples:
===================== =======================
OCaml                 Revised
===================== =======================
<code class="docutils literal"><span class="pre">1,</span> <span class="pre">&quot;hello&quot;,</span> <span class="pre">World</span></code> <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">&quot;hello&quot;,</span> <span class="pre">World)</span></code>
===================== =======================</li>
<li>Lists are always enclosed with brackets. A list is a left bracket,
followed by a list of elements separated with semicolons,
optionally followed by colon-colon and an element, and ended by a
right bracket. Warning: the colon-colon is not an infix but is
just part of the syntactic construction.
==================== ==================
OCaml                Revised
==================== ==================
<code class="docutils literal"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">y</span></code>           <code class="docutils literal"><span class="pre">[x</span> <span class="pre">::</span> <span class="pre">y]</span></code>
<code class="docutils literal"><span class="pre">[x;</span> <span class="pre">y;</span> <span class="pre">z]</span></code>        <code class="docutils literal"><span class="pre">[x;</span> <span class="pre">y;</span> <span class="pre">z]</span></code>
<code class="docutils literal"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">y</span> <span class="pre">::</span> <span class="pre">z</span> <span class="pre">::</span> <span class="pre">t</span></code> <code class="docutils literal"><span class="pre">[x;</span> <span class="pre">y;</span> <span class="pre">z</span> <span class="pre">::</span> <span class="pre">t]</span></code>
==================== ==================</li>
</ul>
<p class="rubric" id="records">Records</p>
<ul class="simple">
<li>In record update, parentheses are required around the initial
expression:
====================== ========================
OCaml                  Revised
====================== ========================
<code class="docutils literal"><span class="pre">{e</span> <span class="pre">with</span> <span class="pre">field</span> <span class="pre">=</span> <span class="pre">a}</span></code> <code class="docutils literal"><span class="pre">{(e)</span> <span class="pre">with</span> <span class="pre">field</span> <span class="pre">=</span> <span class="pre">a}</span></code>
====================== ========================</li>
<li>It is allowable to use function binding syntax in record field
definitions:
======================== =================
OCaml                    Revised
======================== =================
<code class="docutils literal"><span class="pre">{field</span> <span class="pre">=</span> <span class="pre">fun</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">e}</span></code> <code class="docutils literal"><span class="pre">{field</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">e}</span></code>
======================== =================</li>
</ul>
<p class="rubric" id="irrefutable-patterns">Irrefutable patterns</p>
<p>An <em>irrefutable pattern</em> is a pattern which is syntactically visible
and never fails. They are used in some syntactic constructions. It is
either:</p>
<ul class="simple">
<li>A variable,</li>
<li>The wildcard “_”,</li>
<li>The constructor “()”,</li>
<li>A tuple with irrefutable patterns,</li>
<li>A record with irrefutable patterns,</li>
<li>A type constraint with an irrefutable pattern.</li>
</ul>
<p>Notice that this definition is only syntactic: a constructor
belonging to a type having only one constructor is not considered as
an irrefutable pattern (except “()”).</p>
<p class="rubric" id="constructions-with-matching">Constructions with matching</p>
<ul>
<li><p class="first">The keyword “function” no longer exists. Only “fun” is used.</p>
</li>
<li><p class="first">The pattern matching, in constructions with “fun”, “match” and
“try” is closed with brackets: an open bracket “[” before the
first case, and a close bracket “]” after the last case:
================ ================
OCaml            Revised
================ ================
<code class="docutils literal"><span class="pre">match</span> <span class="pre">e</span> <span class="pre">with</span></code> <code class="docutils literal"><span class="pre">match</span> <span class="pre">e</span> <span class="pre">with</span></code>
``&nbsp;&nbsp;p1 -&gt; e1``   <code class="docutils literal"><span class="pre">[</span> <span class="pre">p1</span> <span class="pre">-&gt;</span> <span class="pre">e1</span></code>
<code class="docutils literal"><span class="pre">|</span> <span class="pre">p2</span> <span class="pre">-&gt;</span> <span class="pre">e2</span></code>   <code class="docutils literal"><span class="pre">|</span> <span class="pre">p2</span> <span class="pre">-&gt;</span> <span class="pre">e2</span> <span class="pre">]</span></code>
================ ================</p>
<p>If there is only one case and if the pattern is irrefutable, the
brackets are not required. These examples work identically in
OCaml and in revised syntax:
========================= =========================
OCaml                     Revised
========================= =========================
<code class="docutils literal"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code>            <code class="docutils literal"><span class="pre">fun</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code>
<code class="docutils literal"><span class="pre">fun</span> <span class="pre">{foo=(y,</span> <span class="pre">_)}</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code> <code class="docutils literal"><span class="pre">fun</span> <span class="pre">{foo=(y,</span> <span class="pre">_)}</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code>
========================= =========================</p>
</li>
<li><p class="first">It is possible to write the empty function which always raises the
exception “Match_failure” when a parameter is applied. It is also
possible to write and empty “match”, raising “Match_failure” after
having evaluated its expression and the empty “try”, equivalent to
its expression without try:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="p">[]</span>
<span class="n">match</span> <span class="n">e</span> <span class="k">with</span> <span class="p">[]</span>
<span class="k">try</span> <span class="n">e</span> <span class="k">with</span> <span class="p">[]</span>
</pre></div>
</div>
</li>
<li><p class="first">The patterns after “let” and “value” must be irrefutable. The
following OCaml expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="p">::</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>must be written:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fun</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">::</span><span class="n">y</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="first">It is possible to use a construction “where”, equivalent to “let”,
but usable only when where is only one binding. The expression:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">e1</span> <span class="n">where</span> <span class="n">p</span> <span class="o">=</span> <span class="n">e</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e1</span>
</pre></div>
</div>
</li>
</ul>
<p class="rubric" id="mutables-and-assignment">Mutables and Assignment</p>
<ul class="simple">
<li>The statement “<code class="docutils literal"><span class="pre">&lt;-</span></code>” is written “<code class="docutils literal"><span class="pre">:=</span></code>”:
============ ============
OCaml        Revised
============ ============
<code class="docutils literal"><span class="pre">x.f</span> <span class="pre">&lt;-</span> <span class="pre">y</span></code> <code class="docutils literal"><span class="pre">x.f</span> <span class="pre">:=</span> <span class="pre">y</span></code>
============ ============</li>
<li>The “ref” type is declared as a record type with one field named
“val”, instead of “contents”. The operator “!” does not exist any
more, and references are assigned like the other mutables:
=============== ======================
OCaml           Revised
=============== ======================
<code class="docutils literal"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">!x</span> <span class="pre">+</span> <span class="pre">y</span></code> <code class="docutils literal"><span class="pre">x.val</span> <span class="pre">:=</span> <span class="pre">x.val</span> <span class="pre">+</span> <span class="pre">y</span></code>
=============== ======================</li>
</ul>
<p class="rubric" id="miscellaneous">Miscellaneous</p>
<ul>
<li><p class="first">The “<code class="docutils literal"><span class="pre">else</span></code>” is required in the “<code class="docutils literal"><span class="pre">if</span></code>” statement:
=============== =======================
OCaml           Revised
=============== =======================
<code class="docutils literal"><span class="pre">if</span> <span class="pre">a</span> <span class="pre">then</span> <span class="pre">b</span></code> <code class="docutils literal"><span class="pre">if</span> <span class="pre">a</span> <span class="pre">then</span> <span class="pre">b</span> <span class="pre">else</span> <span class="pre">()</span></code>
=============== =======================</p>
</li>
<li><p class="first">The boolean operations “<code class="docutils literal"><span class="pre">or</span></code>” and “<code class="docutils literal"><span class="pre">and</span></code>” can only be written
with “<code class="docutils literal"><span class="pre">||</span></code>” and “<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>”:
=============== ===============
OCaml           Revised
=============== ===============
<code class="docutils literal"><span class="pre">a</span> <span class="pre">or</span> <span class="pre">b</span> <span class="pre">&amp;</span> <span class="pre">c</span></code>  <code class="docutils literal"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span></code>
<code class="docutils literal"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span></code> <code class="docutils literal"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span></code>
=============== ===============</p>
</li>
<li><p class="first">No more “<code class="docutils literal"><span class="pre">begin</span> <span class="pre">end</span></code>” construction. One must use parentheses.</p>
</li>
<li><p class="first">The operators as values are written with an backslash:
========= ========
OCaml     Revised
========= ========
<code class="docutils literal"><span class="pre">(+)</span></code>   <code class="docutils literal"><span class="pre">\+</span></code>
<code class="docutils literal"><span class="pre">(mod)</span></code> <code class="docutils literal"><span class="pre">\mod</span></code>
========= ========</p>
</li>
<li><p class="first">Nested “as” patterns require parenthesis:
============================== ===============================
OCaml                          Revised
============================== ===============================
<code class="docutils literal"><span class="pre">function</span> <span class="pre">Some</span> <span class="pre">a</span> <span class="pre">as</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">-&gt;</span></code> <code class="docutils literal"><span class="pre">fun</span> <span class="pre">[</span> <span class="pre">((Some</span> <span class="pre">a</span> <span class="pre">as</span> <span class="pre">b),</span> <span class="pre">c)</span> <span class="pre">-&gt;</span></code>
``&nbsp;&nbsp;…``                      ``&nbsp;&nbsp;…``
============================== ===============================</p>
<p>But they are not required before the right arrow:
=========================== ========================
OCaml                       Revised
=========================== ========================
<code class="docutils literal"><span class="pre">function</span> <span class="pre">Some</span> <span class="pre">a</span> <span class="pre">as</span> <span class="pre">b</span> <span class="pre">-&gt;</span></code> <code class="docutils literal"><span class="pre">fun</span> <span class="pre">[</span> <span class="pre">Some</span> <span class="pre">a</span> <span class="pre">as</span> <span class="pre">b</span> <span class="pre">-&gt;</span></code>
``&nbsp;&nbsp;…``                   ``&nbsp;&nbsp;…``
=========================== ========================</p>
</li>
<li><p class="first">The operators with special characters are not automatically infix.
To define infixes, use syntax extensions.</p>
</li>
</ul>
<p class="rubric" id="types-and-constructors">Types and Constructors</p>
<ul>
<li><p class="first">The type constructors are before their type parameters, which are
curryfied:
============================== ================================
OCaml                          Revised
============================== ================================
<code class="docutils literal"><span class="pre">int</span> <span class="pre">list</span></code>                   <code class="docutils literal"><span class="pre">list</span> <span class="pre">int</span></code>
<code class="docutils literal"><span class="pre">('a,</span> <span class="pre">bool)</span> <span class="pre">Hashtbl.t</span></code>       <code class="docutils literal"><span class="pre">Hashtbl.t</span> <span class="pre">'a</span> <span class="pre">bool</span></code>
<code class="docutils literal"><span class="pre">type</span> <span class="pre">'a</span> <span class="pre">foo</span> <span class="pre">=</span> <span class="pre">'a</span> <span class="pre">list</span> <span class="pre">list</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">foo</span> <span class="pre">'a</span> <span class="pre">=</span> <span class="pre">list</span> <span class="pre">(list</span> <span class="pre">'a)</span></code>
============================== ================================</p>
</li>
<li><p class="first">The abstract types are represented by an unbound type variable:
================= =====================
OCaml             Revised
================= =====================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">'a</span> <span class="pre">foo;;</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">foo</span> <span class="pre">'a</span> <span class="pre">=</span> <span class="pre">'b;</span></code>
<code class="docutils literal"><span class="pre">type</span> <span class="pre">bar;;</span></code>    <code class="docutils literal"><span class="pre">type</span> <span class="pre">bar</span> <span class="pre">=</span> <span class="pre">'a;</span></code>
================= =====================</p>
</li>
<li><p class="first">Parentheses are required in tuples of types:
============== ================
OCaml          Revised
============== ================
<code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">bool</span></code> <code class="docutils literal"><span class="pre">(int</span> <span class="pre">*</span> <span class="pre">bool)</span></code>
============== ================</p>
</li>
<li><p class="first">In declarations of a concrete type, brackets must enclose the
constructor declarations:
========================= ============================
OCaml                     Revised
========================= ============================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">of</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">B;;</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">A</span> <span class="pre">of</span> <span class="pre">i</span> <span class="pre">|</span> <span class="pre">B</span> <span class="pre">];</span></code>
========================= ============================</p>
</li>
<li><p class="first">It is possible to make the empty type, without constructor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">[];</span>
</pre></div>
</div>
</li>
<li><p class="first">There is a syntax difference between data constructors with
several parameters and data constructors with one parameter of
type tuple:
The declaration of a data constructor with several parameters is
done by separating the types with “and”. In expressions and
patterns, these constructor parameters must be curryfied:
=========================== ================================
OCaml                       Revised
=========================== ================================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">of</span> <span class="pre">t1</span> <span class="pre">*</span> <span class="pre">t2;;</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">C</span> <span class="pre">of</span> <span class="pre">t1</span> <span class="pre">and</span> <span class="pre">t2</span> <span class="pre">];</span></code>
<code class="docutils literal"><span class="pre">C</span> <span class="pre">(x,</span> <span class="pre">y);;</span></code>              <code class="docutils literal"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">y;</span></code>
=========================== ================================</p>
<p>The declaration of a data constructor with one parameter of type
tuple is done by using a tuple type. In expressions and patterns,
the parameter must not to be curryfied, since it is alone. In that
case the syntax of constructor parameters is the same between the
two syntaxes:
============================= ================================
OCaml                         Revised
============================= ================================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">D</span> <span class="pre">of</span> <span class="pre">(t1</span> <span class="pre">*</span> <span class="pre">t2);;</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">D</span> <span class="pre">of</span> <span class="pre">(t1</span> <span class="pre">*</span> <span class="pre">t2)</span> <span class="pre">];</span></code>
<code class="docutils literal"><span class="pre">D</span> <span class="pre">(x,</span> <span class="pre">y);;</span></code>                <code class="docutils literal"><span class="pre">D</span> <span class="pre">(x,</span> <span class="pre">y);</span></code>
============================= ================================</p>
</li>
<li><p class="first">The bool constructors start with an uppercase letter. The
identifiers “true” and “false” are not keywords:
================= =================
OCaml             Revised
================= =================
<code class="docutils literal"><span class="pre">true</span> <span class="pre">&amp;&amp;</span> <span class="pre">false</span></code> <code class="docutils literal"><span class="pre">True</span> <span class="pre">&amp;&amp;</span> <span class="pre">False</span></code>
================= =================</p>
</li>
<li><p class="first">In record types, the keyword “mutable” must appear after the
colon:
=============================== ==============================
OCaml                           Revised
=============================== ==============================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">{mutable</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">t1};;</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">{x</span> <span class="pre">:</span> <span class="pre">mutable</span> <span class="pre">t1};</span></code>
=============================== ==============================</p>
</li>
<li><p class="first">Manifest types are with “==”:
=========================== ============================
OCaml                       Revised
=========================== ============================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">'a</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">'a</span> <span class="pre">option</span> <span class="pre">=</span></code> <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">'a</span> <span class="pre">=</span> <span class="pre">option</span> <span class="pre">'a</span> <span class="pre">==</span></code>
``&nbsp;&nbsp;&nbsp;&nbsp;None``                ``&nbsp;&nbsp;[ None``
``&nbsp;&nbsp;| Some of ‘a``          ``&nbsp;&nbsp;| Some of ‘a ]``
=========================== ============================</p>
</li>
<li><p class="first">Polymorphic types start with “<code class="docutils literal"><span class="pre">!</span></code>”:
========================== ============================
OCaml                      Revised
========================== ============================
<code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span></code>               <code class="docutils literal"><span class="pre">type</span> <span class="pre">t</span> <span class="pre">=</span></code>
``&nbsp;&nbsp;{ f : ‘a . ‘a list }`` ``&nbsp;&nbsp;{ f : ! ‘a . list ‘a }``
========================== ============================</p>
</li>
</ul>
<p class="rubric" id="streams-and-parsers">Streams and Parsers</p>
<ul>
<li><p class="first">The streams and the stream patterns are bracketed with “<code class="docutils literal"><span class="pre">[:</span></code>”
and “<code class="docutils literal"><span class="pre">:]</span></code>” instead of “<code class="docutils literal"><span class="pre">[&lt;</span></code>” and “<code class="docutils literal"><span class="pre">&gt;]</span></code>”.</p>
</li>
<li><p class="first">The stream component “terminal” is written with a back-quote
instead of a quote:
======================= ==============================
OCaml                   Revised
======================= ==============================
<code class="docutils literal"><span class="pre">[&lt;</span> <span class="pre">'1;</span> <span class="pre">'2;</span> <span class="pre">s;</span> <span class="pre">'3</span> <span class="pre">&gt;]</span></code> <code class="docutils literal"><span class="pre">[:</span> <span class="pre">`1;</span> <span class="pre">`2;</span> <span class="pre">s;</span> <span class="pre">`3</span> <span class="pre">:]</span></code>
======================= ==============================</p>
</li>
<li><p class="first">The cases of parsers are bracketed with “<code class="docutils literal"><span class="pre">[</span></code>” and “<code class="docutils literal"><span class="pre">]</span></code>”, as
with “fun”, “match” and “try”. If there is one case, the brackets
are not required:
========================== ================================
OCaml                      Revised
========================== ================================
<code class="docutils literal"><span class="pre">parser</span></code>                 <code class="docutils literal"><span class="pre">parser</span></code>
``&nbsp;&nbsp;[&lt; ‘Foo &gt;] -&gt; e``      <code class="docutils literal"><span class="pre">[</span> <span class="pre">[:</span> <span class="pre">`Foo</span> <span class="pre">:]</span> <span class="pre">-&gt;</span> <span class="pre">e</span></code>
<code class="docutils literal"><span class="pre">|</span> <span class="pre">[&lt;</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">&gt;]</span> <span class="pre">-&gt;</span> <span class="pre">f;;</span></code>   <code class="docutils literal"><span class="pre">|</span> <span class="pre">[:</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">:]</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">];</span></code>
<code class="docutils literal"><span class="pre">parser</span> <span class="pre">[&lt;</span> <span class="pre">'x</span> <span class="pre">&gt;]</span> <span class="pre">-&gt;</span> <span class="pre">x;;</span></code> <code class="docutils literal"><span class="pre">parser</span> <span class="pre">[:</span> <span class="pre">`x</span> <span class="pre">:]</span> <span class="pre">-&gt;</span> <span class="pre">x;</span></code>
========================== ================================</p>
</li>
<li><p class="first">It is possible to write the empty parser raising the exception
“Stream.Failure” whatever parameter is applied, and the empty
stream matching always raising “Stream.Failure”:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="p">[]</span>
<span class="n">match</span> <span class="n">e</span> <span class="k">with</span> <span class="n">parser</span> <span class="p">[]</span>
</pre></div>
</div>
</li>
<li><p class="first">In normal syntax, the error indicator starts with a double
question mark, in revised syntax with a simple question mark:
================================
======================================
OCaml                            Revised
================================
======================================
<code class="docutils literal"><span class="pre">parser</span></code>                       <code class="docutils literal"><span class="pre">parser</span></code>
``&nbsp;&nbsp;[&lt; ‘1; ‘2 ?? “error” &gt;] -&gt;`` :literal:`&nbsp;&nbsp;[: <cite>1; `2 ? “error” :] -&gt;</cite>
``&nbsp;&nbsp;&nbsp;&nbsp;…``                      ``&nbsp;&nbsp;&nbsp;&nbsp;…``
================================
======================================</p>
</li>
<li><p class="first">In normal syntax, the component optimization starts with “<code class="docutils literal"><span class="pre">?!</span></code>”,
in revised syntax with “<code class="docutils literal"><span class="pre">!</span></code>”:
======================== ==============================
OCaml                    Revised
======================== ==============================
<code class="docutils literal"><span class="pre">parser</span></code>               <code class="docutils literal"><span class="pre">parser</span></code>
``&nbsp;&nbsp;[&lt; ‘1; ‘2 ?! &gt;] -&gt;`` :literal:`&nbsp;&nbsp;[: <cite>1; `2 ! :] -&gt;</cite>
``&nbsp;&nbsp;&nbsp;&nbsp;…``              ``&nbsp;&nbsp;&nbsp;&nbsp;…``
======================== ==============================</p>
</li>
</ul>
<p class="rubric" id="classes-and-objects">Classes and Objects</p>
<ul class="simple">
<li>Object items end with a single semicolon which is required.</li>
<li>Class type parameters follow the class identifier:
============================== ==============================
OCaml                          Revised
============================== ==============================
<code class="docutils literal"><span class="pre">class</span> <span class="pre">['a,</span> <span class="pre">'b]</span> <span class="pre">point</span> <span class="pre">=</span> <span class="pre">...</span></code> <code class="docutils literal"><span class="pre">class</span> <span class="pre">point</span> <span class="pre">['a,</span> <span class="pre">'b]</span> <span class="pre">=</span> <span class="pre">...</span></code>
<code class="docutils literal"><span class="pre">class</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">[int]</span> <span class="pre">color;;</span></code>    <code class="docutils literal"><span class="pre">class</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">color</span> <span class="pre">[int];</span></code>
============================== ==============================</li>
<li>In the type of class with parameters, the type of the parameters
are between brackets. Example in signature:
============================ =============================
OCaml                        Revised
============================ =============================
<code class="docutils literal"><span class="pre">class</span> <span class="pre">c</span> <span class="pre">:</span> <span class="pre">int</span> <span class="pre">-&gt;</span> <span class="pre">point;;</span></code> <code class="docutils literal"><span class="pre">class</span> <span class="pre">c</span> <span class="pre">:</span> <span class="pre">[int]</span> <span class="pre">-&gt;</span> <span class="pre">point;</span></code>
============================ =============================</li>
<li>The keywords “virtual” and “private” must be in this order:
============================== ==============================
OCaml                          Revised
============================== ==============================
<code class="docutils literal"><span class="pre">method</span> <span class="pre">virtual</span> <span class="pre">private</span> <span class="pre">m</span> <span class="pre">:</span></code> <code class="docutils literal"><span class="pre">method</span> <span class="pre">virtual</span> <span class="pre">private</span> <span class="pre">m</span> <span class="pre">:</span></code>
``&nbsp;&nbsp;…``                      ``&nbsp;&nbsp;…``
<code class="docutils literal"><span class="pre">method</span> <span class="pre">private</span> <span class="pre">virtual</span> <span class="pre">m</span> <span class="pre">:</span></code> <code class="docutils literal"><span class="pre">method</span> <span class="pre">virtual</span> <span class="pre">private</span> <span class="pre">m</span> <span class="pre">:</span></code>
``&nbsp;&nbsp;…``                      ``&nbsp;&nbsp;…``
============================== ==============================</li>
<li>Object variables are introduced with “value” instead of “val”:
======================== ===========================
OCaml                    Revised
======================== ===========================
<code class="docutils literal"><span class="pre">object</span> <span class="pre">val</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">end</span></code> <code class="docutils literal"><span class="pre">object</span> <span class="pre">value</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">3;</span> <span class="pre">end</span></code>
======================== ===========================</li>
<li>Type constraints in objects are introduced with “type” instead of
“constraint”:
================================== =============================
OCaml                              Revised
================================== =============================
<code class="docutils literal"><span class="pre">object</span> <span class="pre">constraint</span> <span class="pre">'a</span> <span class="pre">=</span> <span class="pre">int</span> <span class="pre">end</span></code> <code class="docutils literal"><span class="pre">object</span> <span class="pre">type</span> <span class="pre">'a</span> <span class="pre">=</span> <span class="pre">int;</span> <span class="pre">end</span></code>
================================== =============================</li>
</ul>
<p class="rubric" id="labels-and-variants">Labels and Variants</p>
<ul class="simple">
<li>Labels in types must start with “<code class="docutils literal"><span class="pre">~</span></code>”:
============================= ===============================
OCaml                         Revised
============================= ===============================
<code class="docutils literal"><span class="pre">val</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">num:int</span> <span class="pre">-&gt;</span> <span class="pre">bool;;</span></code> <code class="docutils literal"><span class="pre">value</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">~num:int</span> <span class="pre">-&gt;</span> <span class="pre">bool;</span></code>
============================= ===============================</li>
<li></li>
<li></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="scheme.html" class="btn btn-neutral float-right" title="Scheme" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="quot.html" class="btn btn-neutral float-left" title="Quotations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2007-2017, INRIA (Institut National de Recherches en Informatique et Automatique). All rights reserved.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>